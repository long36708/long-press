import{_ as h,a as k,b as r}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.BCVHfIj7.js";import{_ as d,D as c,c as o,b as B,w as i,a8 as u,I as s,a7 as n,o as a,a as g}from"./chunks/framework.DGCt2JJv.js";import"./chunks/dayjs.min.DZyl58SH.js";const H=JSON.parse('{"title":"React Hooks","description":"","frontmatter":{},"headers":[],"relativePath":"react/React Hooks.md","filePath":"react/React Hooks.md","lastUpdated":1718814781000}'),y={name:"react/React Hooks.md"},b=n(`<h1 id="react-hooks" tabindex="-1">React Hooks <a class="header-anchor" href="#react-hooks" aria-label="Permalink to &quot;React Hooks&quot;">​</a></h1><p>React 中通常使用 类定义 或者 函数定义 创建组件:</p><p>在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力， 因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。</p><h2 id="函数编程hooks的好处" tabindex="-1">函数编程hooks的好处: <a class="header-anchor" href="#函数编程hooks的好处" aria-label="Permalink to &quot;函数编程hooks的好处:&quot;">​</a></h2><ul><li>1、跨组件复用: 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；</li><li>2、类定义更为复杂: <ul><li>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；</li><li>时刻需要关注this的指向问题；</li><li>代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；</li></ul></li><li>3、状态与UI隔离: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。</li></ul><div class="tip custom-block"><p class="custom-block-title">注意</p><ul><li>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；</li><li>只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；</li><li>不能在useEffect中使用useState，React 会报错提示；</li><li>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存； 新版推荐使用函数定义组件</li></ul></div><h2 id="重要钩子" tabindex="-1">重要钩子: <a class="header-anchor" href="#重要钩子" aria-label="Permalink to &quot;重要钩子:&quot;">​</a></h2><ul><li>状态钩子 (useState): 用于定义组件的 State，其到类定义中this.state的功能；</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// useState 只接受一个参数: 初始状态</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 返回的是组件名和更改该组件对应的函数</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;">flag</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;">setFlag</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 修改状态</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">setFlag</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li><p>生命周期钩子 (useEffect):</p><p>类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (useEffect)</p><p>这里可以看做componentDidMount、componentDidUpdate和componentWillUnmount的结合。</p></li></ul><p>虽然本质上，依然是 componentDidMount 和 componentDidUpdate 两个生命周期被调用，</p><p>但是现在我们关心的不是 mount 或者 update 过程，而是“after render”事件，useEffect 就是告诉组件在“渲染完”之后做点什么事。</p><p>useEffect(callback, [source])接受两个参数 callback: 钩子回调函数； source: 设置触发条件，仅当 source 发生改变时才会触发；</p><p>useEffect钩子在没有传入[source]参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">useEffect</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 组件挂载后执行事件绑定</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">	console</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;">&#39;on&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">	addEventListener</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	// 组件 update 时会执行事件解绑</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">		console</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;">&#39;off&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">		removeEventListener</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}, [</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">source</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">]);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// --- DidMount ---</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// &#39;on&#39;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// --- DidUpdate ---</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// &#39;off&#39;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// &#39;on&#39;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// --- DidUpdate ---</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// &#39;off&#39;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// &#39;on&#39;</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// --- WillUnmount ---</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// &#39;off&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>通过第二个参数，我们便可模拟出几个常用的生命周期:</p><ul><li>componentDidMount: 传入[]时，就只会在初始化时调用一次；</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useMount</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">fn</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useEffect</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">fn</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">, [])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>componentWillUnmount: 传入[]，回调中的返回的函数也只会被最终执行一次；</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useUnmount</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">fn</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useEffect</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> fn</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">, []);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>mounted: 可以使用 useState 封装成一个高度可复用的 mounted 状态；</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useMounted</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">	const</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;">mounted</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;">setMounted</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">	useEffect</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">		!</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">mounted</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> setMounted</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">		return</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> setMounted</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;">false</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">	}, []);</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> mounted</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>componentDidUpdate: useEffect每次均会执行，其实就是排除了 DidMount 后即可；</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> mounted</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useMounted</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">useEffect</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">	mounted</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> fn</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="依赖项" tabindex="-1">依赖项 <a class="header-anchor" href="#依赖项" aria-label="Permalink to &quot;依赖项&quot;">​</a></h3><table tabindex="0"><thead><tr><th>依赖项规则</th><th>副作用执行规则</th></tr></thead><tbody><tr><td>不传递依赖项</td><td>在每次渲染后都会执行。</td></tr><tr><td>若传递空数组</td><td>只在组件挂载和卸载时执行。</td></tr><tr><td>若传递依赖项</td><td>只在依赖项变化时执行。</td></tr></tbody></table><h3 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h3>`,27),F=n(`<h2 id="其它内置钩子" tabindex="-1">其它内置钩子: <a class="header-anchor" href="#其它内置钩子" aria-label="Permalink to &quot;其它内置钩子:&quot;">​</a></h2><ul><li><p>useContext: 获取 context 对象</p></li><li><p>useReducer: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:</p><p>并不是持久化存储，会随着组件被销毁而销毁； 属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据； 配合useContext的全局性，可以完成一个轻量级的 Redux</p></li><li><p>useCallback: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；</p></li><li><p>useMemo: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；</p></li><li><p>useRef: 获取组件的真实节点；</p></li><li><p>useLayoutEffect: DOM更新同步钩子。用法与useEffect类似，只是区别于执行时间点的不同。 useEffect属于异步执行，并不会等待 DOM 真正渲染后执行， 而useLayoutEffect则会真正渲染后才触发； 可以获取更新后的 state；</p></li><li><p>自定义钩子(useXxxxx): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子，如上面的useMounted。又例如，我们需要每个页面自定义标题:</p></li></ul><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useTitle</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">title</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">	useEffect</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">		() </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">			document</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">title</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> title</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">		});</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 使用:</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> Home</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">	const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> title</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> &#39;我是首页&#39;</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">	useTitle</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">title</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">		&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">title</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">	)</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="在hooks里动态创建ref的方式" tabindex="-1">在hooks里动态创建ref的方式 <a class="header-anchor" href="#在hooks里动态创建ref的方式" aria-label="Permalink to &quot;在hooks里动态创建ref的方式&quot;">​</a></h2><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>import React, {useRef, useState} from &quot;react&quot;;</span></span>
<span class="line"><span>const  Index = () =&gt; {</span></span>
<span class="line"><span> const dom = useRef({}) //默认值要设置成对象，不然动态将ref赋值给modo将会报错</span></span>
<span class="line"><span> const arr = [{name:&#39;1&#39;},{name:&#39;2&#39;}]</span></span>
<span class="line"><span> return &lt;div&gt;</span></span>
<span class="line"><span>    {arr.map((item,index)=&gt;{</span></span>
<span class="line"><span>    return  &lt;div key={index} ref={node =&gt; dom.current[&#39;domRef&#39;+index] = node}&gt;</span></span>
<span class="line"><span>       {item.name}</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>    })}</span></span>
<span class="line"><span> &lt;div&gt;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default Index</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="tip custom-block"><p class="custom-block-title">注意</p><p>useEffect 只应该依赖参与 React 自上而下数据流的变量，比如 props，state，或者由它们计算出来的值。</p><p>而 Ref 是用于在渲染数据流外改变的值，当 refs 发生变化，react 并不会知道，当然也就并不会触发重新渲染。</p></div><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;Contributors&quot;">​</a></h2>`,7);function m(E,A,f,C,D,v){const l=c("Mermaid"),e=h,t=k,p=r;return a(),o("div",null,[b,(a(),B(u,null,{default:i(()=>[s(l,{id:"mermaid-182",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20A(%E5%BC%80%E5%A7%8B)%20--%3E%20B%5B%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%5D%0A%20%20%20%20B%20--%3E%20C%5B%E6%89%A7%E8%A1%8C%E5%89%AF%E4%BD%9C%E7%94%A8%5D%0A%20%20%20%20C%20--%3E%20D%7B%E7%BB%84%E4%BB%B6%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%7D%0A%20%20%20%20D%20--%3E%7C%E6%9C%89%E4%BE%9D%E8%B5%96%E5%8F%98%E6%9B%B4%7C%20E%5B%E6%B8%85%E7%90%86%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8%5D%0A%20%20%20%20E%20--%3E%20F%5B%E6%89%A7%E8%A1%8C%E5%89%AF%E4%BD%9C%E7%94%A8%5D%0A%20%20%20%20D%20--%3E%7C%E6%97%A0%E4%BE%9D%E8%B5%96%E5%8F%98%E6%9B%B4%7C%20G%5B%E4%BF%9D%E6%8C%81%E7%8A%B6%E6%80%81%5D%0A%20%20%20%20F%20--%3E%20H%7B%E7%BB%84%E4%BB%B6%E6%98%AF%E5%90%A6%E5%8D%B8%E8%BD%BD%7D%0A%20%20%20%20H%20--%3E%7C%E6%98%AF%7C%20I%5B%E6%B8%85%E7%90%86%E5%89%AF%E4%BD%9C%E7%94%A8%5D%0A%20%20%20%20H%20--%3E%7C%E5%90%A6%7C%20D%0A%20%20%20%20I%20--%3E%20J(%E7%BB%93%E6%9D%9F)%0A"})]),fallback:i(()=>[g(" Loading... ")]),_:1})),F,s(e,{readTime:"5",words:"1.5k"}),s(t),s(p)])}const q=d(y,[["render",m]]);export{H as __pageData,q as default};
