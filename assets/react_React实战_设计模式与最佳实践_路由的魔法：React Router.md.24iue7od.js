import{_ as p,a as r,b as l}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.BCVHfIj7.js";import{_ as i,c,I as a,j as s,a as o,a7 as u,o as b}from"./chunks/framework.DGCt2JJv.js";import"./chunks/dayjs.min.DZyl58SH.js";const A=JSON.parse('{"title":"路由的魔法：React Router","description":"","frontmatter":{},"headers":[],"relativePath":"react/React实战,设计模式与最佳实践/路由的魔法：React Router.md","filePath":"react/React实战,设计模式与最佳实践/路由的魔法：React Router.md","lastUpdated":1709130291000}'),d={name:"react/React实战,设计模式与最佳实践/路由的魔法：React Router.md"},m=s("h1",{id:"路由的魔法-react-router",tabindex:"-1"},[o("路由的魔法：React Router "),s("a",{class:"header-anchor",href:"#路由的魔法-react-router","aria-label":'Permalink to "路由的魔法：React Router"'},"​")],-1),h=u(`<p>随着 AJAX 技术的成熟，现在单页应用（Single Page Application）已经是前端网页界的标配，名为“单页”，</p><p>其实在设计概念上依然是多页的界面，只不过从技术层面上页之间的切换是没有整体网页刷新的，只需要做局部更新。</p><p>要实现“单页应用”，一个最要紧的问题就是做好“路由”（Routing)，也就是处理好下面两件事：</p><ul><li>把 URL 映射到对应的页面来处理；</li><li>页面之间切换做到只需局部更新。</li></ul><p>感谢业界前人给我们开发者铺平了道路，在 React 的世界里，上面说的问题都有成熟解法，其中最热门的工具，就是 react-router，这一节我们就来介绍这个工具。</p><h2 id="react-router-v4-的动态路由" tabindex="-1">react router v4 的动态路由 <a class="header-anchor" href="#react-router-v4-的动态路由" aria-label="Permalink to &quot;react router v4 的动态路由&quot;">​</a></h2><p>我们现在说到 react-router，基本上都是在说 react-router 的第 4 版，也就是 v4。 这个 v4 很有意思，它完全推翻了之前 v3 的做法。可以说，react-router 的 v3 和 v4 版完完全全是不同的两个工具，两者差距实在太大。</p><p>其实当初 v3 也已经很优秀很热门了，但是 react-router 的开发者不满意，他们认为 v3 还是落入了“静态路由”的窠臼，所以在 v4 中 react-router 做到了“动态路由”的功能。</p><p>所谓“静态路由”，就是说路由规则是固定的，无论 express、Angular 还是 Rails 等业界响当当的框架，都用的是静态路由。 以 express 为例，路由规则差不多是这么写的：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>app.get(&#39;/&#39;, Home);</span></span>
<span class="line"><span>app.get(&#39;/product/:id&#39;, Product);</span></span>
<span class="line"><span>app.get(&#39;/about&#39;, About);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>对于大部分应用，支持这样的路由规则真的是足够了，但是，react-router 的开发者觉得这样还不够好，要支持“动态路由”才是最好。</p><p>所谓动态路由，指的是路由规则不是预先确定的，而是在渲染过程中确定的。 因为 react-router 的定位就是专供 React 应用服务，而 React 的世界中一切皆为组件，所以 react-router v4 就完全用 React 组件来实现路由功能。</p><p>不得不承认，虽然 react-router 的开发者是挺折腾的，但是他们的确是领悟了 React 的精髓，而且在 react-router 中把 React 的哲学发挥到了极致。</p><p>接下来，我们通过一个很简单的例子来说明 react-router v4 如何工作的，然后在这个例子的基础上介绍“动态路由”。</p><h2 id="react-router-实例" tabindex="-1">React Router 实例 <a class="header-anchor" href="#react-router-实例" aria-label="Permalink to &quot;React Router 实例&quot;">​</a></h2><h3 id="安装包-react-router-dom" tabindex="-1">安装包 react-router-dom <a class="header-anchor" href="#安装包-react-router-dom" aria-label="Permalink to &quot;安装包 react-router-dom&quot;">​</a></h3><p>create-react-app 产生的应用默认为不支持多个页面，但还是在 README 文件中友情推荐了一下 react-router 来增强功能，可见 react-router 影响力之大。</p><p>不过，我们并不需要安装 react-router 这个 npm 包，因为 react-router 为了支持 Web 和 React Native 出了两个包—— react-router-dom 和 react-router-native ，我们只关心 Web，所以只需要安装 react-router-dom 。</p><p>这个 react-router-dom 依赖于 react-router ，所以 react-router 也会被自动安装上。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">npm</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> react-router-dom</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="hashrouter-还是-browserrouter" tabindex="-1">HashRouter 还是 BrowserRouter <a class="header-anchor" href="#hashrouter-还是-browserrouter" aria-label="Permalink to &quot;HashRouter 还是 BrowserRouter&quot;">​</a></h3><p>react-router 的工作方式，是在组件树顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件（注意比 Router 少一个“r”），顶层的 Router 组件负责分析监听 URL 的变化，在它保护伞之下的 Route 组件可以直接读取这些信息。</p><p>很明显，Router 和 Route 的配合，就是之前我们介绍过的“提供者模式”，Router 是“提供者”，Route是“消费者”。</p><p>更进一步，Router 其实也是一层抽象，让下面的 Route 无需各种不同 URL 设计的细节，不要以为 URL 就一种设计方法，至少可以分为两种。</p><p>第一种很自然，比如 / 对应 Home 页，/about 对应 About 页，但是这样的设计需要服务器端渲染，因为用户可能直接访问任何一个 URL，服务器端必须能对 /的访问返回 HTML，也要对 /about 的访问返回 HTML。</p><p>第二种看起来不自然，但是实现更简单。只有一个路径 /，通过 URL 后面的 # 部分来决定路由，/#/ 对应 Home 页，/#/about 对应 About 页。因为 URL 中#之后的部分是不会发送给服务器的，所以，无论哪个 URL，最后都是访问服务器的 / 路径，服务器也只需要返回同样一份 HTML 就可以，然后由浏览器端解析 # 后的部分，完成浏览器端渲染。</p><p>在 react-router，有 BrowserRouter 支持第一种 URL，有 HashRouter 支持第二种 URL。</p><p>因为 create-react-app 产生的应用默认不支持服务器端渲染，为了简单起见，我们在下面的例子中使用 HashRouter，在实际产品中，其实最好还是用 BrowserRouter，这样用户体验更好。</p><p>修改index.js文件，增加下面的代码：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>import { HashRouter } from &#39;react-router-dom&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ReactDOM.render(</span></span>
<span class="line"><span>	&lt;HashRouter&gt;</span></span>
<span class="line"><span>		&lt;App /&gt;</span></span>
<span class="line"><span>	&lt;/HashRouter&gt;,</span></span>
<span class="line"><span>	document.getElementById(&#39;root&#39;)</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>把 Router 用在 React 组件树的最顶层，这是最佳实践。因为将来我们如果想把 HashRouter 换成 BrowserRouter，组件 App 以下几乎不用任何改变。</p><h2 id="使用-link" tabindex="-1">使用 Link <a class="header-anchor" href="#使用-link" aria-label="Permalink to &quot;使用 Link&quot;">​</a></h2><p>对于单页应用，需要在不同“页面”之间切换，往往需要一个“导航栏”，我们在这里也实现一个简单的导航栏。</p><p>在App.js中，我们让网页由两个组件 Navigation 和 Content 组成， Navigation 就是导航栏，而 Content 是具体内容。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>class App extends Component {</span></span>
<span class="line"><span>	render() {</span></span>
<span class="line"><span>		return (</span></span>
<span class="line"><span>			&lt;div className=&quot;App&quot;&gt;</span></span>
<span class="line"><span>				&lt;Navigation /&gt;</span></span>
<span class="line"><span>				&lt;Content /&gt;</span></span>
<span class="line"><span>			&lt;/div&gt;</span></span>
<span class="line"><span>		);</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们计划只增加两个页面，在 Navigation 中就应该有两个链接，但是，如果我们简单使用 HTML 的 <code>&lt;a&gt;</code> 标签那就错了，用户点击 <code>&lt;a&gt;</code> 标签缺省行为是网页跳转，这违背了“单页应用”的原则。</p><p>虽然对于 HashRouter 使用的是没有网页跳转的 #，但是为了将来可以无缝切换为 BrowserRouter ，我们也不能 使用 <code>&lt;a href=&quot;#about&quot;&gt;</code>这样的标签。</p><p>正确的解法是用 react-router 提供的 Link 组件，虽然 Link 最终还是渲染为 <code>&lt;a&gt;</code> 标签，但这是有神力的 <code>&lt;a&gt;</code> 标签，</p><p>用户点击时，react-router 可以知晓这是一个单页应用的链接，不用网页跳转只做局部页面更新。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>const ulStyle = {</span></span>
<span class="line"><span>	&#39;list-style-type&#39;: &#39;none&#39;,</span></span>
<span class="line"><span>	margin: 0,</span></span>
<span class="line"><span>	padding: 0,</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const liStyle = {</span></span>
<span class="line"><span>	display: &#39;inline-block&#39;,</span></span>
<span class="line"><span>	width: &#39;60px&#39;,</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const Navigation = () =&gt; (</span></span>
<span class="line"><span>	&lt;header&gt;</span></span>
<span class="line"><span>		&lt;nav&gt;</span></span>
<span class="line"><span>			&lt;ul style={ulStyle}&gt;</span></span>
<span class="line"><span>				&lt;li style={liStyle}&gt;&lt;Link to=&#39;/&#39;&gt;Home&lt;/Link&gt;&lt;/li&gt;</span></span>
<span class="line"><span>				&lt;li style={liStyle}&gt;&lt;Link to=&#39;/about&#39;&gt;About&lt;/Link&gt;&lt;/li&gt;</span></span>
<span class="line"><span>			&lt;/ul&gt;</span></span>
<span class="line"><span>		&lt;/nav&gt;</span></span>
<span class="line"><span>	&lt;/header&gt;</span></span>
<span class="line"><span>)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="使用-route-和-switch" tabindex="-1">使用 Route 和 Switch <a class="header-anchor" href="#使用-route-和-switch" aria-label="Permalink to &quot;使用 Route 和 Switch&quot;">​</a></h2><p>我们来看 Content 这个组件，这里会用到 react-router 最常用的两个组件 Route 和 Switch。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>const Content = () =&gt; (</span></span>
<span class="line"><span>	&lt;main&gt;</span></span>
<span class="line"><span>		&lt;Switch&gt;</span></span>
<span class="line"><span>			&lt;Route exact path=&#39;/&#39; component={Home} /&gt;</span></span>
<span class="line"><span>			&lt;Route path=&#39;/about&#39; component={About} /&gt;</span></span>
<span class="line"><span>		&lt;/Switch&gt;</span></span>
<span class="line"><span>	&lt;/main&gt;</span></span>
<span class="line"><span>)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Route 组件的 path 属性用于匹配路径，因为我们需要匹配 / 到 Home，匹配 /about 到 About，所以肯定需要两个 Route，但是，我们不能这么写。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>&lt;Route path=&#39;/&#39; component={Home} /&gt;</span></span>
<span class="line"><span>&lt;Route path=&#39;/about&#39; component={About} /&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果按照上面这么写，当访问 /about 页面时，不光匹配 /about，也配中 /，界面上会把 Home 和 About 都渲染出来的。</p><p>解决方法，可以在想要精确匹配的 Route 上加一个属性 exact，或者使用 Switch 组件。</p><p>可以把 Switch 组件看做是 JavaScript 的 switch 语句，像这样：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>switch (条件) {</span></span>
<span class="line"><span>	case 1:</span></span>
<span class="line"><span>		渲染1;</span></span>
<span class="line"><span>		break;</span></span>
<span class="line"><span>	case 2:</span></span>
<span class="line"><span>		渲染2;</span></span>
<span class="line"><span>		break;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>从上往下找第一个匹配的 Route，匹配中了之后，立刻就 break，不继续这个 Switch 下其他的 Route 匹配了。</p><p>可以看到，react-router 巧妙地用 React 组件实现了路由的所有逻辑，印证了那句话：React 世界里一切都是组件。</p><h2 id="动态路由" tabindex="-1">动态路由 <a class="header-anchor" href="#动态路由" aria-label="Permalink to &quot;动态路由&quot;">​</a></h2><p>在了解了 react-router的基本路由功能之后，再来理解“动态路由”就容易了。</p><p>假设，我们增加一个新的页面叫 Product，对应路径为 /product，但是只有用户登录了之后才显示。</p><p>如果用静态路由，我们在渲染之前就确定这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 Product 组件中做用户是否登录的检查。</p><p>如果用动态路由，则只需要在代码中的一处涉及这个逻辑：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>&lt;Switch&gt;</span></span>
<span class="line"><span>	&lt;Route exact path=&#39;/&#39; component={Home} /&gt;</span></span>
<span class="line"><span>	{</span></span>
<span class="line"><span>		isUserLogin() &amp;&amp;</span></span>
<span class="line"><span>		&lt;Route exact path=&#39;/product&#39; component={Product} /&gt;,</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>	&lt;Route path=&#39;/about&#39; component={About} /&gt;</span></span>
<span class="line"><span>&lt;/Switch&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>可以用任何条件决定 Route 组件实例是否渲染，比如，可以根据页面宽度、设备类型决定路由规则，动态路由有了最大的自由度。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>这一小节我们介绍了 React 世界中最热门的路由工具 react-router，读者应该能够理解：</p><p>单页应用中路由功能的必要； 如何使用 react-router v4 来实现路由； 动态路由的意义。</p><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;Contributors&quot;">​</a></h2>`,62);function g(v,R,k,x,_,y){const n=p,e=r,t=l;return b(),c("div",null,[m,a(n,{readTime:"7",words:"2.2k"}),h,a(e),a(t)])}const L=i(d,[["render",g]]);export{A as __pageData,L as default};
