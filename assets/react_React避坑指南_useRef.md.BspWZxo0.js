import{_ as r,a as t,b as p}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.BCVHfIj7.js";import{_ as u,c as i,I as e,a7 as l,o}from"./chunks/framework.DGCt2JJv.js";import"./chunks/dayjs.min.DZyl58SH.js";const q=JSON.parse('{"title":"useRef","description":"","frontmatter":{},"headers":[],"relativePath":"react/React避坑指南/useRef.md","filePath":"react/React避坑指南/useRef.md","lastUpdated":1712398251000}'),c={name:"react/React避坑指南/useRef.md"},f=l(`<h1 id="useref" tabindex="-1">useRef <a class="header-anchor" href="#useref" aria-label="Permalink to &quot;useRef&quot;">​</a></h1><p>为了在函数组件中保存状态，useRef就被创造出来，它将会在函数组件的生命周期中，保持状态不变，除非手动进行修改。</p><p>但是，当 ref 对象内容发生变化时，useRef 并不会通知你。</p><p>变更 .current 属性不会引发组件重新渲染。</p><p>如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p><h2 id="forward-ref应该与useimperativehandle一起使用" tabindex="-1">forward Ref应该与useImperativeHandle一起使用 <a class="header-anchor" href="#forward-ref应该与useimperativehandle一起使用" aria-label="Permalink to &quot;forward Ref应该与useImperativeHandle一起使用&quot;">​</a></h2><p>useImperativeHandle可以让你在使用ref时自定义暴露给父组件的实例。不要直接使用forward Ref，forward Ref应该与useImperativeHandle一起使用</p><p>ref：定义 current 对象的 ref createHandle：一个函数，返回值是一个对象，即这个 ref 的 current</p><p>对象 [deps]：即依赖列表，当监听的依赖发生变化，useImperativeHandle 才会重新将子组件的实例属性输出到父组件</p><p>ref 的 current 属性上，如果为空数组，则不会重新输出。</p><h2 id="使用它可以有效地减少组件的重新执行次数-并且是立即生效的-上一行改变可以直接在下一行获取到最新的状态" tabindex="-1">使用它可以有效地减少组件的重新执行次数，并且是立即生效的，上一行改变可以直接在下一行获取到最新的状态 <a class="header-anchor" href="#使用它可以有效地减少组件的重新执行次数-并且是立即生效的-上一行改变可以直接在下一行获取到最新的状态" aria-label="Permalink to &quot;使用它可以有效地减少组件的重新执行次数，并且是立即生效的，上一行改变可以直接在下一行获取到最新的状态&quot;">​</a></h2><p>一般来讲，我们会使用 useRef存储一些访问一些 Dom 元素的属性，存储定时器 ID，保存一些数据， 其他页面上如果触发的更新操作过于频繁的话，完全可以使用 useRef的返回值来代替，最后只需要使用一个 useState或者 useEffect来更新页面即可。</p><p>此外，useRef 还有其他作用，由于 useRef的返回值改变并不会触发页面的重渲染，可以使用它来保存一些不需要用户看到的数据或者状态， 使用它可以有效地减少组件的重新执行次数，并且是立即生效的，上一行改变可以直接在下一行获取到最新的状态，并不像 useState 的返回值一样，需要在下次更新时才能拿到。 所以考虑多在项目中使用 useRef是个不错的选择。</p><h2 id="使用useimperativehandle自定义暴露给父组件的实例值" tabindex="-1">使用useImperativeHandle自定义暴露给父组件的实例值 <a class="header-anchor" href="#使用useimperativehandle自定义暴露给父组件的实例值" aria-label="Permalink to &quot;使用useImperativeHandle自定义暴露给父组件的实例值&quot;">​</a></h2><p>在使用forwardRef时，自定义父组件可以使用的ref操作。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>function FancyInput(props, ref) {</span></span>
<span class="line"><span>  const inputRef = useRef();</span></span>
<span class="line"><span>  useImperativeHandle(ref, () =&gt; ({</span></span>
<span class="line"><span>    focus: () =&gt; {</span></span>
<span class="line"><span>      inputRef.current.focus();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }));</span></span>
<span class="line"><span>  return &lt;input ref={inputRef} /&gt;;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>FancyInput = forwardRef(FancyInput);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="useref-和usestate-之间的区别一目了然" tabindex="-1">useRef 和useState 之间的区别一目了然 <a class="header-anchor" href="#useref-和usestate-之间的区别一目了然" aria-label="Permalink to &quot;useRef 和useState 之间的区别一目了然&quot;">​</a></h2><p>下面的区别已经被详细讨论过了，但在这里再一次以简洁的总结的形式呈现。</p><p>两者都在渲染周期和UI更新期间保留其数据，但只有useState Hook及其更新函数会导致重新渲染</p><p>useRef 会返回一个对象，该对象有一个current 的属性来保存实际值。相比之下，useState 返回一个有两个元素的数组：第一项构成状态，第二项代表状态更新器函数</p><p>useRef的current 属性是可变的，但useState的状态变量不是。 与useRef 的current 属性不同，你不应该直接给useState 的状态变量赋值。 相反，总是使用updater函数（即第二个数组项）。 正如React团队在基于类的组件中的setState 文档中所建议的那样（但对于函数组件来说仍然如此），将状态视为不可变的变量</p><p>useState 和useRef 可以被认为是数据钩子，但只有useRef 可以用于另一个应用领域：获得对 React 组件或 DOM 元素的直接访问</p><p>如果你想更新数据并导致UI更新，useState 是你的Hook。 如果你在整个组件的生命周期中需要某种数据容器，而不会在突变你的变量时引起渲染周期，那么useRef 是你的解决方案。</p><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;Contributors&quot;">​</a></h2>`,24);function d(m,h,b,R,_,v){const a=r,s=t,n=p;return o(),i("div",null,[f,e(a,{readTime:"3",words:"947"}),e(s),e(n)])}const x=u(c,[["render",d]]);export{q as __pageData,x as default};
