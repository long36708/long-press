import{_ as i,a as t,b as p}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.BCVHfIj7.js";import{_ as l,c as r,I as s,a7 as c,o as h}from"./chunks/framework.DGCt2JJv.js";import"./chunks/dayjs.min.DZyl58SH.js";const C=JSON.parse('{"title":"React核心概念 core-concepts","description":"","frontmatter":{},"headers":[],"relativePath":"react/react-core-concepts.md","filePath":"react/react-core-concepts.md","lastUpdated":1719758327000}'),o={name:"react/react-core-concepts.md"},d=c(`<h1 id="react核心概念-core-concepts" tabindex="-1">React核心概念 core-concepts <a class="header-anchor" href="#react核心概念-core-concepts" aria-label="Permalink to &quot;React核心概念 core-concepts&quot;">​</a></h1><h2 id="cra-create-react-app" tabindex="-1">CRA - Create React App <a class="header-anchor" href="#cra-create-react-app" aria-label="Permalink to &quot;CRA - Create React App&quot;">​</a></h2><p>CRA 使用 webpack 作为打包工具，和 vite 是竞品。</p><p>vite既是打包工具，又是构建工具。</p><p>Create React App 曾使用最多的脚手架，React 官方现已经不推荐</p><p>官网<a href="https://create-react-app.dev/" target="_blank" rel="noreferrer">https://create-react-app.dev/</a></p><h3 id="创建项目" tabindex="-1">创建项目 <a class="header-anchor" href="#创建项目" aria-label="Permalink to &quot;创建项目&quot;">​</a></h3><p>PS：直接使用 typescript</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>## 使用 npx</span></span>
<span class="line"><span>npx create-react-app my-app --template typescript</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## 使用 npm</span></span>
<span class="line"><span>npm init react-app my-app --template typescript</span></span>
<span class="line"><span></span></span>
<span class="line"><span>## 使用 yarn</span></span>
<span class="line"><span>yarn create react-app my-app --template typescript</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="jsx" tabindex="-1">JSX <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;JSX&quot;">​</a></h2><p>X在编程里一般代表扩展的意思</p><p>jsx即，js的扩展，可以在 JS 中写模板（类似 HTML 语法）</p><p>Rxjs 即对 响应数据的扩展 js</p><p>JSX 是 React 提供的可以在 JavaScript 中编写类似 HTML 的代码的语法糖，它可以让开发者更方便的描述 UI 的结构。</p><p>JSX 不能直接在浏览器中运行，需要通过 Babel 等工具将 JSX 转换为 JavaScript 代码。</p><p><a href="./react官网阅读笔记#标记语法-markup-syntax-jsx">标记语法（markup syntax） JSX</a></p><h2 id="状态变量-state" tabindex="-1">状态变量 state <a class="header-anchor" href="#状态变量-state" aria-label="Permalink to &quot;状态变量 state&quot;">​</a></h2><p><code>const [A,setA] = useState(0)</code> 其中 A称为 状态变量</p><p>通过 React 提供的 Hook API：<code>useState()</code>可以用来操作组件中的状态。 <code>useState()</code>接受一个初始状态值，返回一个数组，数组的第一个元素是当前状态值，第二个元素是一个函数，用来更新状态值。</p><ul><li><strong>State 变量</strong>用于保存渲染间的数据</li></ul><p>state 是 React 中的组件内部状态，当 state 发生变化时，会触发组件的重新渲染。</p><p>状态更新函数可以接受一个函数作为参数，函数的参数是上一个状态值，返回值是新的状态值。</p><p>使用展开运算符：<code>...pre</code>，可以更新状态对象的部分属性，并保持其他属性不变。</p><p>特别注意对象或数组类型, 不能直接修改，推荐使用immer.js</p><h2 id="set函数" tabindex="-1"><code>set函数</code> <a class="header-anchor" href="#set函数" aria-label="Permalink to &quot;\`set函数\`&quot;">​</a></h2><h3 id="例如setsomething-nextstate" tabindex="-1">例如<code>setSomething(nextState)</code> <a class="header-anchor" href="#例如setsomething-nextstate" aria-label="Permalink to &quot;例如\`setSomething(nextState)\`&quot;">​</a></h3><ul><li><code>useState</code> 返回的 <code>set</code> 函数允许你将 state 更新为不同的值并触发重新渲染</li><li>你可以直接传递新状态，也可以传递一个根据先前状态来计算新状态的函数</li><li>如果你将函数作为<code>nextState</code>传递，它将被视为<strong>更新函数</strong></li></ul><h2 id="state-更新函数" tabindex="-1"><a href="https://zh-hans.react.dev/reference/react/useState#updating-state-based-the-previous-state" target="_blank" rel="noreferrer">state 更新函数</a> <a class="header-anchor" href="#state-更新函数" aria-label="Permalink to &quot;[state 更新函数](https://zh-hans.react.dev/reference/react/useState#updating-state-based-the-previous-state)&quot;">​</a></h2><p><a href="https://zh-hans.react.dev/reference/react/useState#updating-state-based-on-the-previous-state" target="_blank" rel="noreferrer">updater function</a></p><p>setMessages(<strong>msgs =&gt; [...msgs, receivedMessage]</strong>);</p><ul><li>它必须是纯函数，只接受待定的 state 作为其唯一参数，并应返回下一个状态。</li><li>React 将把你的更新函数放入队列中并重新渲染组件。</li><li>在下一次渲染期间，React 将通过把队列中所有更新函数应用于先前的状态来计算下一个状态</li><li>它获取 待定状态 并从中计算 下一个状态</li><li></li></ul><h2 id="初始化函数" tabindex="-1">初始化函数 <a class="header-anchor" href="#初始化函数" aria-label="Permalink to &quot;初始化函数&quot;">​</a></h2><p>React 只在初次渲染时保存初始状态，后续渲染时将其忽略。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>function TodoList() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const [todos, setTodos] = useState(createInitialTodos());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>尽管 <code>createInitialTodos()</code> 的结果仅用于初始渲染，但你仍然在每次渲染时调用此函数。如果它创建大数组或执行昂贵的计算，这可能会浪费资源。</p><p>为了解决这个问题，你可以将它 <strong>作为初始化函数传递给</strong> <code>useState</code>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>function TodoList() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const [todos, setTodos] = useState(createInitialTodos);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // ...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>请注意，你传递的是 <code>createInitialTodos</code> <strong>函数本身</strong>，而不是 <code>createInitialTodos()</code> 调用该函数的结果。如果将函数传递给 <code>useState</code>，React 仅在初始化期间调用它。</p><p>React 在开发模式下可能会调用你的 <a href="https://zh-hans.react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice" target="_blank" rel="noreferrer">初始化函数</a> 两次，以验证它们是否是 <a href="https://zh-hans.react.dev/learn/keeping-components-pure" target="_blank" rel="noreferrer">纯函数</a>。</p><h3 id="我尝试将-state-设置为一个函数-但它却被调用了-https-zh-hans-react-dev-reference-react-usestate-im-trying-to-set-state-to-a-function-but-it-gets-called-instead-link-for-我尝试将-state-设置为一个函数-但它却被调用了" tabindex="-1">我尝试将 state 设置为一个函数，但它却被调用了](<a href="https://zh-hans.react.dev/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead" target="_blank" rel="noreferrer">https://zh-hans.react.dev/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead</a> &quot;Link for 我尝试将 state 设置为一个函数，但它却被调用了 &quot;) <a class="header-anchor" href="#我尝试将-state-设置为一个函数-但它却被调用了-https-zh-hans-react-dev-reference-react-usestate-im-trying-to-set-state-to-a-function-but-it-gets-called-instead-link-for-我尝试将-state-设置为一个函数-但它却被调用了" aria-label="Permalink to &quot;我尝试将 state 设置为一个函数，但它却被调用了](https://zh-hans.react.dev/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead &quot;Link for 我尝试将 state 设置为一个函数，但它却被调用了 &quot;)&quot;">​</a></h3><p>你不能像这样把函数放入状态：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>const [fn, setFn] = useState(someFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function handleClick() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  setFn(someOtherFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>因为你传递了一个函数，React 认为 <code>someFunction</code> 是一个 <a href="https://zh-hans.react.dev/reference/react/useState#avoiding-recreating-the-initial-state" target="_blank" rel="noreferrer">初始化函数</a>， 而 <code>someOtherFunction</code> 是一个 <a href="https://zh-hans.react.dev/reference/react/useState#updating-state-based-on-the-previous-state" target="_blank" rel="noreferrer">更新函数</a> ，于是它尝试调用它们并存储结果。 要实际 <strong>存储</strong> 一个函数，你必须在两种情况下在它们之前加上 <code>() =&gt;</code>。然后 React 将存储你传递的函数。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>const [fn, setFn] = useState(() =&gt; someFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function handleClick() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  setFn(() =&gt; someOtherFunction);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="原始值" tabindex="-1">原始值 <a class="header-anchor" href="#原始值" aria-label="Permalink to &quot;原始值&quot;">​</a></h2><h2 id="响应性值" tabindex="-1">响应性值 <a class="header-anchor" href="#响应性值" aria-label="Permalink to &quot;响应性值&quot;">​</a></h2><ul><li>可能因组件重新渲染而改变的值</li><li>响应式值包括 props、state 以及所有直接在组件内部声明的变量和函数</li></ul><h2 id="非响应性的值" tabindex="-1">非响应性的值 <a class="header-anchor" href="#非响应性的值" aria-label="Permalink to &quot;非响应性的值&quot;">​</a></h2><p>组件外的值，它不会因为重新渲染而改变，所以它不是依赖</p><h2 id="props" tabindex="-1">props <a class="header-anchor" href="#props" aria-label="Permalink to &quot;props&quot;">​</a></h2><p>props 是 React 中提供的将数据从父组件传递到子组件的机制，是父子组件通信的一种方式。</p><p>在 React 中 props 是<strong>只读</strong>的，子组件不能修改 props，以保证数据的单向流动。</p><p>在子组件中，可以使用解构赋值的方式获取 props 中的数据。</p><p>除了传递数据，还可以通过 props 传递函数，实现父子组件之间的通信。</p><p>在子组件中，可以使用剩余参数的方式获取除了指定的 props 之外的其他 props。</p><p>在子组件中，可以给 props 设置默认值，当父组件没有传递该 props 时，使用默认值。</p><h2 id="children" tabindex="-1">children <a class="header-anchor" href="#children" aria-label="Permalink to &quot;children&quot;">​</a></h2><p><code>children</code> 是一个特殊的 prop，它允许将组件作为数据传递到其他组件。</p><p><code>props.children</code>可以是任意的 JSX 元素，包括原始值、React 元素、函数、组件等。</p><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> Page</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  header</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  content</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  footer</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}: {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">  header</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#E5C07B;">JSX</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#267F99;--shiki-dark:#E5C07B;">Element</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">  content</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#E5C07B;">JSX</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#267F99;--shiki-dark:#E5C07B;">Element</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">  footer</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#267F99;--shiki-dark:#E5C07B;">JSX</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#267F99;--shiki-dark:#E5C07B;">Element</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}) {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">      {</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">header</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">      {</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">content</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">      {</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">footer</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">  );</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;"> default</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> ChildrenMultiple</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#267F99;--shiki-dark:#E5C07B;">Page</span></span>
<span class="line"><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      header</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">页头</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      content</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">页面内容</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">      footer</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">页尾</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">h1</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">    &gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#267F99;--shiki-dark:#E5C07B;">Page</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">  );</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="事件处理程序" tabindex="-1">事件处理程序 <a class="header-anchor" href="#事件处理程序" aria-label="Permalink to &quot;事件处理程序&quot;">​</a></h2><p>对交互的直接反应，而非间接</p><h2 id="setup-函数" tabindex="-1">setup 函数 <a class="header-anchor" href="#setup-函数" aria-label="Permalink to &quot;setup 函数&quot;">​</a></h2><p>useEffect(setup, dependencies?)</p><ul><li>处理 Effect 的函数。setup 函数选择性返回一个 <strong>清理（cleanup）</strong> 函数。</li><li>当组件被添加到 DOM 的时候，React 将运行 setup 函数。</li><li>在每次依赖项变更重新渲染后，React 将首先使用旧值运行 cleanup 函数（如果你提供了该函数），然后使用新值运行 setup 函数。</li><li>在组件从 DOM 中移除后，React 将最后一次运行 cleanup 函数。</li></ul><p><strong>可选</strong> <code>dependencies</code> <strong>依赖项列表</strong></p><ul><li><code>setup</code> 代码中引用的所有响应式值的列表。响应式值包括 props、state 以及所有直接在组件内部声明的变量和函数。</li><li>依赖项列表的元素数量必须是固定的，并且必须像 <code>[dep1, dep2, dep3]</code> 这样内联编写。</li><li>React 将使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="noreferrer"><code>Object.is</code></a> 来比较每个依赖项和它先前的值。</li><li>如果省略此参数，则在每次重新渲染组件之后，将重新运行 Effect 函数</li></ul><h2 id="ref-对象" tabindex="-1">ref 对象 <a class="header-anchor" href="#ref-对象" aria-label="Permalink to &quot;ref 对象&quot;">​</a></h2><p><code>useRef</code> 返回一个具有单个 <code>current</code> 属性 的 ref 对象，并初始化为你提供的 初始值。</p><ul><li>在后续的渲染中，<code>useRef</code> 将返回相同的对象。你可以改变它的 <code>current</code> 属性来存储信息，并在之后读取它。</li></ul><h2 id="渲染期间" tabindex="-1">渲染期间 <a class="header-anchor" href="#渲染期间" aria-label="Permalink to &quot;渲染期间&quot;">​</a></h2><p>函数组件中，非hooks内，非事件处理函数内 包括 函数组件的大部分，return 中的jsx</p><h2 id="记忆化与记忆函数" tabindex="-1">记忆化与记忆函数 <a class="header-anchor" href="#记忆化与记忆函数" aria-label="Permalink to &quot;记忆化与记忆函数&quot;">​</a></h2><h2 id="箭头函数体" tabindex="-1">箭头函数体 <a class="header-anchor" href="#箭头函数体" aria-label="Permalink to &quot;箭头函数体&quot;">​</a></h2><h3 id="我调用的usememo应该返回一个对象-但返回了undefined" tabindex="-1">我调用的<code>useMemo</code>应该返回一个对象，但返回了<code>undefined</code><a href="https://zh-hans.react.dev/reference/react/useMemo#my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined" title="Link for this heading" target="_blank" rel="noreferrer"></a> <a class="header-anchor" href="#我调用的usememo应该返回一个对象-但返回了undefined" aria-label="Permalink to &quot;我调用的\`useMemo\`应该返回一个对象，但返回了\`undefined\`[](https://zh-hans.react.dev/reference/react/useMemo#my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined &quot;Link for this heading&quot;)&quot;">​</a></h3><p>这段代码不起作用：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>  // 🔴 你不能像这样 \`() =&gt; {\` 在箭头函数中直接返回一个对象</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const searchOptions = useMemo(() =&gt; {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    matchMode: &#39;whole-word&#39;,</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    text: text</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  }, [text]);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在 JavaScript 中，<code>() =&gt; {</code> 是箭头函数体的开始标志，因此 <code>{</code> 大括号不是对象的一部分。这就是它不返回对象并导致错误的原因。你可以通过添加像 <code>({</code> 与 <code>})</code> 这样的括号来修复它：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>  // 这行得通，但很容易有人再次破坏</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const searchOptions = useMemo(() =&gt; ({</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    matchMode: &#39;whole-word&#39;,</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    text: text</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  }), [text]);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>然而，这仍然令人困惑，而且对于某些人来说，通过移除括号来破坏它太容易了。</p><p>为避免此错误，请显式编写 <code>return</code> 语句：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>// ✅ 这有效并且是明确的</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const searchOptions = useMemo(() =&gt; {</span></span>
<span class="line"><span>    return {</span></span>
<span class="line"><span>      matchMode: &#39;whole-word&#39;,</span></span>
<span class="line"><span>      text: text</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span>}, [text]);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="reducer" tabindex="-1">reducer <a class="header-anchor" href="#reducer" aria-label="Permalink to &quot;reducer&quot;">​</a></h2><p>用于更新 state 的纯函数。 参数为 state 和 action，返回值是更新后的 state。 state 与 action 可以是任意合法值。</p><h2 id="dispatch函数" tabindex="-1"><a href="https://zh-hans.react.dev/reference/react/useReducer#dispatch" target="_blank" rel="noreferrer"><code>dispatch</code>函数</a> <a class="header-anchor" href="#dispatch函数" aria-label="Permalink to &quot;[\`dispatch\`函数](https://zh-hans.react.dev/reference/react/useReducer#dispatch)&quot;">​</a></h2><ul><li>用于更新 state 并触发组件的重新渲染</li><li>它需要传入一个 action 作为参数</li><li><code>dispatch</code> 函数没有返回值</li></ul><h2 id="action" tabindex="-1">action <a class="header-anchor" href="#action" aria-label="Permalink to &quot;action&quot;">​</a></h2><ul><li>用户执行的操作。可以是任意类型的值。</li><li>通常来说 action 是一个对象，其中<code>type</code>属性标识类型，其它属性携带额外信息。</li></ul><h2 id="纯函数" tabindex="-1">纯函数 <a class="header-anchor" href="#纯函数" aria-label="Permalink to &quot;纯函数&quot;">​</a></h2><ul><li><strong>只有组件、初始化函数和 reducer 函数需要是纯函数</strong>。</li><li>事件处理函数不需要实现为纯函数，并且 React 永远不会调用事件函数两次。</li><li><a href="https://zh-hans.react.dev/learn/keeping-components-pure" target="_blank" rel="noreferrer">React 假设编写的每个组件都是纯函数</a>。这意味着编写的 React 组件在给定相同的输入（props、state 和 context）时必须始终返回相同的 JSX。</li><li>如果一个函数是纯函数，运行两次不会改变其行为，因为纯函数每次都会产生相同的结果。 然而，如果一个函数是非纯函数（例如，它会修改接收到的数据），运行两次通常会产生明显的差异（这就是它是非纯函数的原因！）。这有助于及早发现并修复错误。</li></ul><h2 id="标记为转换效果" tabindex="-1">标记为转换效果 <a class="header-anchor" href="#标记为转换效果" aria-label="Permalink to &quot;标记为转换效果&quot;">​</a></h2><ul><li>使用 useTransition()</li><li>startTransition()包裹切换</li></ul><h2 id="render函数" tabindex="-1"><code>render</code>函数 <a class="header-anchor" href="#render函数" aria-label="Permalink to &quot;\`render\`函数&quot;">​</a></h2><ul><li>组件的渲染函数。React 会调用该函数并传入父组件传递的 props 和<code>ref</code>。</li><li>返回的 JSX 将作为组件的输出。</li></ul><h2 id="错误边界" tabindex="-1">错误边界 <a class="header-anchor" href="#错误边界" aria-label="Permalink to &quot;错误边界&quot;">​</a></h2><p>错误边界用于 React 中捕获子组件树中发生的 JavaScript 错误，并输出这些错误，防止整个应用崩溃。</p><p>错误边界可以捕获渲染期间、生命周期方法以及其下整个树的构造函数中发生的错误。</p><h2 id="受控组件" tabindex="-1">受控组件 <a class="header-anchor" href="#受控组件" aria-label="Permalink to &quot;受控组件&quot;">​</a></h2><p>受控组件：值同步到state,并且使用value属性</p><p>受控组件是指表单元素的值由 React 组件的 state 控制的表单元素。</p><p>受控组件的表单中的输入值由 React 组件的 state 控制，通过 <code>onChange()</code> 事件来更新 state。</p><p>非受控组件：值不同步到state,使用defaultValue属性</p><p>非受控组件是指表单元素的值不受 React 控制，而是由 DOM 元素本身来控制的组件。</p><p>非受控组件的表单中的输入值不受 React 控制，通过<code>useRef()</code>保存 DOM 元素的引用，并通过<code>current</code>属性来获取 DOM 元素的值。</p><h2 id="formdata" tabindex="-1">FormData <a class="header-anchor" href="#formdata" aria-label="Permalink to &quot;FormData&quot;">​</a></h2><p>FormData 是内置的表单对象，用于创建表单数据对象。</p><p>FormData 对象包含表单中的数据，<code>Object.fromEntries(formData.entries())</code>将 FormData 对象转换为普通的 JavaScript 对象。</p><h2 id="状态提升-lifting-state-up" tabindex="-1">状态提升 Lifting State Up <a class="header-anchor" href="#状态提升-lifting-state-up" aria-label="Permalink to &quot;状态提升 Lifting State Up&quot;">​</a></h2><p>状态提升是一种在 React 中处理共享状态的方法。 当多个组件需要共享相同的数据时，可以将该数据提升到这些组件的最近共同祖先中。 这样，这些组件就可以通过 props 来访问和修改这个共享的数据。</p><h1 id="初学react的感受" tabindex="-1">初学React的感受 <a class="header-anchor" href="#初学react的感受" aria-label="Permalink to &quot;初学React的感受&quot;">​</a></h1><p>1.与vue相比，react使用jsx,将html标签与js相混合，结构灵活。而vue使用模板语法，具有明显的template,script,css，结构标准化。</p><p>2.渲染diff算法不同，react默认会将整个组件进行重新渲染，类似于canvas，运用不好可能容易有性能问题。 Object.is 进行比较是否有变化。依赖收集需要开发者自己指明，否则容易陷入闭包陷阱。</p><p>vue会自动进行细粒度的比较，自动依赖收集，上手简单。</p><p>3.修改数据，react中不应该直接修改useState创建的数据，而应该拷贝一份副本,否则认为是mutation突变。 vue中采用双向数据绑定，可以直接对数据进行修改，框架本身会根据依赖收集自动处理，使得数据的更新更直观。</p><p>4.响应式，react中，没有类似vue的指令，需要自己实现，父组件定义子组件中需要触发的方法，单向数据流体现的更明显。</p><p>react的组件化更明显，因为hooks只能在顶层调用，并且循环中不可以使用，需要把循环项抽成子组件，才能使用useCallback</p><p>5.React中对于状态，需要理解的十分透彻才行。在渲染期间中，由数据间关系可以计算出来的，可以放到渲染期间useMemo中，类似于vue中的计算属性。 不要放到useEffect，类似于vue中的watch。</p><p>6.vue中可以使用ref调用子组件的方法，但是react中对单向数据流的要求更高，推荐由父组件中定义，通过props传递给子组件</p><ol start="7"><li>vue就像是精装房，家具什么的都给你准备好了，官方提供了比较完整的解决方案</li></ol><p>React就像是毛坯房，需要你自己处理，如果你很懂装修之类的，可能会比精装房还好。</p><p>React有一个非常庞大的生态系统，开发者需要根据需求选择合适的库进行搭配。</p><p>感觉react是 开发中发现哪种场景不满足，就写一个hook,弱化了生命周期的概念</p><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;Contributors&quot;">​</a></h2>`,123);function k(u,b,m,g,f,B){const a=i,e=t,n=p;return h(),r("div",null,[d,s(a,{readTime:"11",words:"3.4k"}),s(e),s(n)])}const x=l(o,[["render",k]]);export{C as __pageData,x as default};
