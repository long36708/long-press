import{_ as r,a as p,b as o}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.BCVHfIj7.js";import{_ as l,c as h,j as c,t as d,I as e,a7 as a,o as k}from"./chunks/framework.DGCt2JJv.js";import"./chunks/dayjs.min.DZyl58SH.js";const E=JSON.parse('{"title":"React官网阅读笔记","description":"","frontmatter":{},"headers":[],"relativePath":"react/react官网阅读笔记.md","filePath":"react/react官网阅读笔记.md","lastUpdated":1715012587000}'),u={name:"react/react官网阅读笔记.md"},f=a('<h1 id="react官网阅读笔记" tabindex="-1">React官网阅读笔记 <a class="header-anchor" href="#react官网阅读笔记" aria-label="Permalink to &quot;React官网阅读笔记&quot;">​</a></h1><p>现代 JavaScript 教程 <a href="https://zh.javascript.info/" target="_blank" rel="noreferrer">https://zh.javascript.info/</a></p><h2 id="react组件" tabindex="-1">React组件 <a class="header-anchor" href="#react组件" aria-label="Permalink to &quot;React组件&quot;">​</a></h2><p>React 组件名称必须始终以大写字母开头，而 HTML 标签必须以小写字母开头</p><p>Instead of copy-pasting, React’s component architecture allows you to create a reusable component to avoid messy, duplicated code. React 的组件架构允许你创建一个可重用的组件，以避免混乱、重复的代码，而不是复制粘贴。</p><h2 id="标记语法-markup-syntax-jsx" tabindex="-1">标记语法（markup syntax） JSX <a class="header-anchor" href="#标记语法-markup-syntax-jsx" aria-label="Permalink to &quot;标记语法（markup syntax） JSX&quot;">​</a></h2><p>JSX is stricter than HTML. You have to close tags like <code>&lt;br /&gt;</code>. Your component also can’t return multiple JSX tags. You have to wrap them into a shared parent, like a <code>&lt;div&gt;...&lt;/div&gt;</code> or an empty <code>&lt;&gt;...&lt;/&gt;</code> wrapper:</p><p>JSX 比 HTML 更严格。 您必须关闭 <code> &lt;br /&gt;</code> 您的组件也无法返回多个 JSX 标签。 您必须将它们包装到共享父级中，例如 <code>&lt;div&gt;...&lt;/div&gt;</code> 或 <code>&lt;&gt;...&lt;/&gt;</code> 空包装器</p><p>JSX 允许您将标记放入 JavaScript 中。大括号可以让你“转义回”到 JavaScript 中，这样你就可以从代码中嵌入一些变量并将其显示给用户。</p><p>要从 JSX “转义到 JavaScript”，您需要大括号。</p><p>Each React component is a JavaScript function that may contain some markup that React renders into the browser. 每个 React 组件都是一个 JavaScript 函数，它会返回一些标签，React 会将这些标签渲染到浏览器上。</p><p>React components use a syntax extension called JSX to represent that markup. React 组件使用一种被称为 JSX 的语法扩展来描述这些标签。</p><p>JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. JSX 看起来和 HTML 很像，但它的语法更加严格并且可以动态展示信息。</p><h3 id="jsx-规则" tabindex="-1">JSX 规则 <a class="header-anchor" href="#jsx-规则" aria-label="Permalink to &quot;JSX 规则&quot;">​</a></h3><ol><li>只能返回一个根元素 如果想要在一个组件中包含多个元素，需要用一个父标签把它们包裹起来 如果你不想在标签中增加一个额外的 <code>&lt;div&gt;</code>，可以用 <code>&lt;&gt; 和 &lt;/&gt;</code> 元素来代替 React Fragment 允许你将子元素分组，而不会在 HTML 结构中添加额外节点。</li></ol><div class="tip custom-block"><p class="custom-block-title">为什么多个 JSX 标签需要被一个父元素包裹？</p><p>JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象， 你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。 这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。</p></div><ol start="2"><li><p>标签必须闭合</p></li><li><p>使用驼峰式命名法给 <s>所有</s> 大部分属性命名！ JSX 最终会被转化为 JavaScript，而 JSX 中的属性也会变成 JavaScript 对象中的键值对。 在你自己的组件中，经常会遇到需要用变量的方式读取这些属性的时候。 但 JavaScript 对变量的命名有限制。 例如，变量名称不能包含 <code>-</code> 符号或者像 <code>class</code> 这样的保留字。</p><p>这就是为什么在 React 中，大部分 HTML 和 SVG 属性都用驼峰式命名法表示。例如，需要用 strokeWidth 代替 stroke-width。 由于 class 是一个保留字，所以在 React 中需要用 className 来代替。</p></li></ol><blockquote><p>JSX and React are two separate things. They’re often used together, but you can use them independently of each other. JSX and React 是相互独立的 东西。但它们经常一起使用，但你 可以 单独使用它们中的任意一个 JSX is a syntax extension, while React is a JavaScript library. JSX 是一种语法扩展，而 React 则是一个 JavaScript 的库。</p></blockquote><h3 id="可以在哪使用大括号" tabindex="-1">可以在哪使用大括号? <a class="header-anchor" href="#可以在哪使用大括号" aria-label="Permalink to &quot;可以在哪使用大括号?&quot;">​</a></h3><p>在 JSX 中，只能在以下两种场景中使用大括号：</p><p>用作 JSX 标签内的文本：<code>&lt;h1&gt;{name}&#39;s To Do List&lt;/h1&gt; </code>是有效的，但是<code> &lt;{tag}&gt;Gregorio Y. Zara&#39;s To Do List&lt;/{tag}&gt;</code> 无效。 用作紧跟在 <code>=</code> 符号后的 属性：<code>src={avatar}</code> 会读取 avatar 变量，但是 <code>src=&quot;{avatar}&quot; </code>只会传一个字符串 {avatar}。</p><h3 id="使用-双大括号-jsx-中的-css-和-对象" tabindex="-1">使用 “双大括号”：JSX 中的 CSS 和 对象 <a class="header-anchor" href="#使用-双大括号-jsx-中的-css-和-对象" aria-label="Permalink to &quot;使用 “双大括号”：JSX 中的 CSS 和 对象&quot;">​</a></h3>',22),m=a(`<h3 id="在一些情况下-你不想有任何东西进行渲染" tabindex="-1">在一些情况下，你不想有任何东西进行渲染 <a class="header-anchor" href="#在一些情况下-你不想有任何东西进行渲染" aria-label="Permalink to &quot;在一些情况下，你不想有任何东西进行渲染&quot;">​</a></h3><p>这种情况下，你可以直接返回 null。 实际上，在组件里返回 null 并不常见，因为这样会让想使用它的开发者感觉奇怪。 通常情况下，你可以在父组件里选择是否要渲染该组件。</p><h3 id="切勿将数字放在-左侧" tabindex="-1">切勿将数字放在 &amp;&amp; 左侧. <a class="header-anchor" href="#切勿将数字放在-左侧" aria-label="Permalink to &quot;切勿将数字放在 &amp;&amp; 左侧.&quot;">​</a></h3><p>JavaScript 会自动将左侧的值转换成布尔类型以判断条件成立与否。 然而，如果左侧是 0，整个表达式将变成左侧的值（0），React 此时则会渲染 0 而不是不进行渲染。</p><p>例如，一个常见的错误是 <code>messageCount &amp;&amp; &lt;p&gt;New messages&lt;/p&gt;</code>。其原本是想当 messageCount 为 0 的时候不进行渲染，但实际上却渲染了 0。</p><p>为了更正，可以将左侧的值改成布尔类型：<code>messageCount &gt; 0 &amp;&amp; &lt;p&gt;New messages&lt;/p&gt;</code>。</p><h3 id="当一个相似的-jsx-树结构在两个情况下都返回的时候-最好将它们写成一个单独的-jsx" tabindex="-1">当一个相似的 JSX 树结构在两个情况下都返回的时候，最好将它们写成一个单独的 JSX <a class="header-anchor" href="#当一个相似的-jsx-树结构在两个情况下都返回的时候-最好将它们写成一个单独的-jsx" aria-label="Permalink to &quot;当一个相似的 JSX 树结构在两个情况下都返回的时候，最好将它们写成一个单独的 JSX&quot;">​</a></h3><p>请记住，如果两个不同的 JSX 代码块描述着相同的树结构，它们的嵌套（第一个 <code>&lt;div&gt; </code>→ 第一个 <code>&lt;img&gt;</code>）必须对齐。</p><p>否则切换 isActive 会再次在后面创建整个树结构并且 重置 state。 这也就是为什么当一个相似的 JSX 树结构在两个情况下都返回的时候，最好将它们写成一个单独的 JSX。</p><h2 id="呈现组件列表" tabindex="-1">呈现组件列表 <a class="header-anchor" href="#呈现组件列表" aria-label="Permalink to &quot;呈现组件列表&quot;">​</a></h2><p>you will rely on JavaScript features like for loop and the array map() function to render lists of components. 您将依靠 for loop 和 array map() 函数等 JavaScript 功能来呈现组件列表</p><blockquote><p>注意：对于列表中的每个项目，应传递一个字符串或数字，以在其同级中唯一标识该项目。 通常，密钥应该来自您的数据，例如数据库 ID。 React 使用您的密钥来了解以后插入、删除或重新排序项目时会发生什么。</p></blockquote><p>In most cases, you’d need the actual array elements, but to render a list of moves you will only need indexes. 在大多数情况下，您需要实际的数组元素，但要呈现移动列表，您只需要索引。</p><h3 id="列表项的唯一键key" tabindex="-1">列表项的唯一键key <a class="header-anchor" href="#列表项的唯一键key" aria-label="Permalink to &quot;列表项的唯一键key&quot;">​</a></h3><p>When a list is re-rendered, React takes each list item’s key and searches the previous list’s items for a matching key. If the current list has a key that didn’t exist before, React creates a component. If the current list is missing a key that existed in the previous list, React destroys the previous component. If two keys match, the corresponding component is moved.</p><p>当列表被重新渲染时，React 会获取每个列表项的键，并在上一个列表的项中搜索匹配的键。 如果当前列表有一个以前不存在的键，React 会创建一个组件。 如果当前列表缺少上一个列表中存在的键，React 会销毁上一个组件。 如果两个键匹配，则移动相应的组件。</p><p>Keys tell React about the identity of each component, which allows React to maintain state between re-renders. If a component’s key changes, the component will be destroyed and re-created with a new state.</p><p>键告诉 React 每个组件的身份，这允许 React 在重新渲染之间保持状态。 如果组件的键发生更改，则该组件将被销毁并使用新状态重新创建。</p><p>Keys do not need to be globally unique; they only need to be unique between components and their siblings. 密钥不需要是全局唯一的;它们只需要在组件及其同级之间是唯一的。</p><p>key is a special and reserved property in React. When an element is created, React extracts the key property and stores the key directly on the returned element. Even though key may look like it is passed as props, React automatically uses key to decide which components to update. There’s no way for a component to ask what key its parent specified. key 是 React 中的特殊保留属性。 创建元素时，React 会提取 key 属性并将键直接存储在返回的元素上。 尽管它 key 看起来像是作为道具传递的，但 React 会自动使用它 key 来决定要更新哪些组件。 组件无法询问其父级指定了什么 key 。</p><p>It’s strongly recommended that you assign proper keys whenever you build dynamic lists. If you don’t have an appropriate key, you may want to consider restructuring your data so that you do.</p><p>强烈建议您在构建动态列表时分配适当的键。 如果没有适当的密钥，则可能需要考虑重构数据，以便这样做。</p><h3 id="简短的-fragment-语法不允许你传递密钥-因此您需要将它们分组到一个-div-或者使用稍长且更明确的-fragment-语法" tabindex="-1">简短的 <code>&lt;&gt;...&lt;/&gt; </code>Fragment 语法不允许你传递密钥，因此您需要将它们分组到一个 <code>&lt;div&gt;</code> ，或者使用稍长且更明确的 <code>&lt;Fragment&gt;</code> 语法 <a class="header-anchor" href="#简短的-fragment-语法不允许你传递密钥-因此您需要将它们分组到一个-div-或者使用稍长且更明确的-fragment-语法" aria-label="Permalink to &quot;简短的 \`&lt;&gt;...&lt;/&gt; \`Fragment 语法不允许你传递密钥，因此您需要将它们分组到一个 \`&lt;div&gt;\` ，或者使用稍长且更明确的 \`&lt;Fragment&gt;\` 语法&quot;">​</a></h3><p>The short <code>&lt;&gt;...&lt;/&gt;</code> Fragment syntax won’t let you pass a key, so you need to either group them into a single <code>&lt;div&gt;</code>, or use the slightly longer and more explicit<code>&lt;Fragment&gt;</code>syntax: 简短的 <code>&lt;&gt;...&lt;/&gt; </code>Fragment 语法不允许你传递密钥，因此您需要将它们分组到一个 <code>&lt;div&gt;</code> ，或者使用稍长且更明确的 <code>&lt;Fragment&gt;</code> 语法</p><h3 id="如何设定-key-值" tabindex="-1">如何设定 key 值 <a class="header-anchor" href="#如何设定-key-值" aria-label="Permalink to &quot;如何设定 key 值&quot;">​</a></h3><p>不同来源的数据往往对应不同的 key 值获取方式：</p><p>来自数据库的数据： 如果你的数据是从数据库中获取的，那你可以直接使用数据表中的主键，因为它们天然具有唯一性。</p><p>Locally generated data: If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter, <code>crypto.randomUUID()</code> or a package like <code>uuid</code> when creating items. 本地产生数据： 如果你数据的产生和保存都在本地（例如笔记软件里的笔记），那么你可以使用一个自增计数器或者一个类似 <code>uuid</code> 的库来生成 key。</p><h3 id="key-需要满足的条件" tabindex="-1">key 需要满足的条件 <a class="header-anchor" href="#key-需要满足的条件" aria-label="Permalink to &quot;key 需要满足的条件&quot;">​</a></h3><p>Keys must be unique among siblings. However, it’s okay to use the same keys for JSX nodes in different arrays. key 值在兄弟节点之间必须是唯一的。 不过不要求全局唯一，在不同的数组中可以使用相同的 key。</p><p>Keys must not change or that defeats their purpose! Don’t generate them while rendering. key 值不能改变，否则就失去了使用 key 的意义！所以千万不要在渲染时动态地生成 key。</p><h3 id="react-中为什么需要-key" tabindex="-1">React 中为什么需要 key？ <a class="header-anchor" href="#react-中为什么需要-key" aria-label="Permalink to &quot;React 中为什么需要 key？&quot;">​</a></h3><p>设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。 也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。 原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……</p><p>React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。 而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。</p><p>你可能会想直接把数组项的索引当作 key 值来用，实际上，如果你没有显式地指定 key 值，React 确实默认会这么做。 但是数组项的顺序在插入、删除或者重新排序等操作中会发生改变，此时把索引顺序用作 key 值会产生一些微妙且令人困惑的 bug。</p><p>与之类似，请不要在运行过程中动态地产生 key，像是 <code>key={Math.random()}</code> 这种方式。 这会导致每次重新渲染后的 key 值都不一样，从而使得所有的组件和 DOM 元素每次都要重新创建。 这不仅会造成运行变慢的问题，更有可能导致用户输入的丢失。 所以，使用能从给定数据中稳定取得的值才是明智的选择。</p><p>有一点需要注意，组件不会把 key 当作 props 的一部分。 Key 的存在只对 React 本身起到提示作用。 如果你的组件需要一个 ID，那么请把它作为一个单独的 prop 传给组件： <code>&lt;Profile key={id} userId={id} /&gt;</code>。</p><h3 id="因为箭头函数会隐式地返回位于-之后的表达式-所以你可以省略-return-语句。" tabindex="-1">因为箭头函数会隐式地返回位于 =&gt; 之后的表达式，所以你可以省略 return 语句。 <a class="header-anchor" href="#因为箭头函数会隐式地返回位于-之后的表达式-所以你可以省略-return-语句。" aria-label="Permalink to &quot;因为箭头函数会隐式地返回位于 =&gt; 之后的表达式，所以你可以省略 return 语句。&quot;">​</a></h3><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> listItems</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;"> chemists</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">map</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">person</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;"> =&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">	&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">li</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">li</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> // 隐式地返回！</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>不过，如果你的 =&gt; 后面跟了一对花括号 <code>{ </code>，那你必须使用 return 来指定返回值！</p><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> listItems</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;"> chemists</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">map</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">person</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 花括号</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">li</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">li</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Arrow functions containing <code>=&gt; {</code> are said to have a “block body”. They let you write more than a single line of code, but you have to write a return statement yourself. If you forget it, nothing gets returned!</p><p>箭头函数 <code>=&gt; {</code> 后面的部分被称为 “块函数体”，块函数体支持多行代码的写法，但要用 return 语句才能指定返回值。 假如你忘了写 return，那这个函数什么都不会返回！</p><h2 id="事件处理程序函数-event-handler-functions" tabindex="-1">事件处理程序函数 event handler functions <a class="header-anchor" href="#事件处理程序函数-event-handler-functions" aria-label="Permalink to &quot;事件处理程序函数  event handler functions&quot;">​</a></h2><p>请注意 <code>onClick={handleClick}</code> ，末尾没有括号！不要调用事件处理程序函数：你只需要向下传递它。当用户单击按钮时，React 将调用事件处理程序。</p><p>事件处理程序函数通常用于制作交互式组件 Making an interactive component</p><p>使用箭头函数定义函数</p><p>In React, it’s conventional to use onSomething names for props which represent events and handleSomething for the function definitions which handle those events. 在 React 中，通常使用 onSomething 表示事件的 props 和 handleSomething 处理这些事件的函数定义的名称。</p><p>Event handlers are your own functions that will be triggered in response to interactions like clicking, hovering, focusing form inputs, and so on. 事件处理函数为自定义函数，它将在响应交互（如点击、悬停、表单输入框获得焦点等）时触发。</p><h3 id="事件处理函数有如下特点" tabindex="-1">事件处理函数有如下特点: <a class="header-anchor" href="#事件处理函数有如下特点" aria-label="Permalink to &quot;事件处理函数有如下特点:&quot;">​</a></h3><p>通常在你的组件 内部 定义。 名称以 handle 开头，后跟事件名称。</p><h3 id="传递给事件处理函数的函数应直接传递-而非调用。" tabindex="-1">传递给事件处理函数的函数应直接传递，而非调用。 <a class="header-anchor" href="#传递给事件处理函数的函数应直接传递-而非调用。" aria-label="Permalink to &quot;传递给事件处理函数的函数应直接传递，而非调用。&quot;">​</a></h3><p>如果你想要定义内联事件处理函数，请将其包装在匿名函数中</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>&lt;button onClick={() =&gt; alert(&#39;你点击了我！&#39;)} /&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里创建了一个稍后调用的函数，而不会在每次渲染时执行其内部代码。</p><h3 id="通常-我们会在父组件中定义子组件的事件处理函数。" tabindex="-1">通常，我们会在父组件中定义子组件的事件处理函数。 <a class="header-anchor" href="#通常-我们会在父组件中定义子组件的事件处理函数。" aria-label="Permalink to &quot;通常，我们会在父组件中定义子组件的事件处理函数。&quot;">​</a></h3><p>内置组件（<code>&lt;button&gt; 和 &lt;div&gt;</code>）仅支持 浏览器事件名称，例如 onClick。 但是，当你构建自己的组件时，你可以按你个人喜好命名事件处理函数的 prop。 按照惯例，事件处理函数 props 应该以 on 开头，后跟一个大写字母。</p><h3 id="确保为事件处理程序使用适当的-html-标签。" tabindex="-1">确保为事件处理程序使用适当的 HTML 标签。 <a class="header-anchor" href="#确保为事件处理程序使用适当的-html-标签。" aria-label="Permalink to &quot;确保为事件处理程序使用适当的 HTML 标签。&quot;">​</a></h3><p>例如，要处理点击事件，请使用 <code>&lt;button onClick={handleClick}&gt;</code> 而不是 <code>&lt;div onClick={handleClick}&gt;</code>。 使用真正的浏览器 <code>&lt;button&gt;</code> 启用内置的浏览器行为，如键盘导航。 如果你不喜欢按钮的默认浏览器样式，并且想让它看起来更像一个链接或不同的 UI 元素，你可以使用 CSS 来实现。</p><h3 id="事件传播" tabindex="-1">事件传播 <a class="header-anchor" href="#事件传播" aria-label="Permalink to &quot;事件传播&quot;">​</a></h3><p>事件处理函数还将捕获任何来自子组件的事件。 通常，我们会说事件会沿着树向上“冒泡”或“传播”：它从事件发生的地方开始，然后沿着树向上传播。</p><blockquote><p>在 React 中所有事件都会传播，除了 onScroll，它仅适用于你附加到的 JSX 标签。</p></blockquote><p>如果你想阻止一个事件到达父组件，你需要像下面 Button 组件那样调用 <code>e.stopPropagation()</code></p><p>不要混淆 e.stopPropagation() 和 e.preventDefault()。它们都很有用，但二者并不相关：</p><p>e.stopPropagation() 阻止触发绑定在外层标签上的事件处理函数。 e.preventDefault() 阻止少数事件的默认浏览器行为。</p><h3 id="事件处理函数是执行副作用的最佳位置" tabindex="-1">事件处理函数是执行副作用的最佳位置 <a class="header-anchor" href="#事件处理函数是执行副作用的最佳位置" aria-label="Permalink to &quot;事件处理函数是执行副作用的最佳位置&quot;">​</a></h3><p>Event handlers are the best place for side effects.</p><p>Unlike rendering functions, event handlers don’t need to be pure, so it’s a great place to change something—for example, change an input’s value in response to typing, or change a list in response to a button press. However, in order to change some information, you first need some way to store it. In React, this is done by using state, a component’s memory. 与渲染函数不同，事件处理函数不需要是 纯函数，因此它是用来 更改 某些值的绝佳位置。 例如，更改输入框的值以响应键入，或者更改列表以响应按钮的触发。 但是，为了更改某些信息，你首先需要某种方式存储它。 在 React 中，这是通过 state（组件的记忆） 来完成的</p><h2 id="使用-usestate记住一些信息-并更新它" tabindex="-1">使用 useState记住一些信息，并更新它 <a class="header-anchor" href="#使用-usestate记住一些信息-并更新它" aria-label="Permalink to &quot;使用 useState记住一些信息，并更新它&quot;">​</a></h2><p>Often, you’ll want your component to “remember” some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add state to your component. 通常，您会希望组件“记住”一些信息并显示它。例如，您可能想要计算单击按钮的次数。为此，请向组件添加状态。</p><p>You’ll get two things from useState: the current state (count), and the function that lets you update it (setCount). You can give them any names, but the convention is to write [something, setSomething]. 您将从 useState 以下位置获得两件事：当前状态 （ count ） 和允许您更新它的函数 （ setCount ）。 你可以给他们起任何名字，但惯例是写 [something, setSomething] .</p><p>如果多次渲染同一组件，则每个组件都会获得自己的状态</p><p>To “remember” things, components use state. 为了“记住”事物，组件使用状态。</p><p>In fact, always try to avoid redundant state. Simplifying what you store in state reduces bugs and makes your code easier to understand.</p><p>事实上，总是尽量避免冗余状态。 简化存储状态的内容可以减少错误，并使代码更易于理解。</p><p>state状态仅保留用于交互性，即随时间变化的数据。 To make the UI interactive, you need to let users change your underlying data model. You will use state for this. 若要使 UI 具有交互性，需要允许用户更改基础数据模型。为此，您将使用 state。</p><h3 id="state-组件的记忆" tabindex="-1">State：组件的记忆 <a class="header-anchor" href="#state-组件的记忆" aria-label="Permalink to &quot;State：组件的记忆&quot;">​</a></h3><p>组件通常需要根据交互更改屏幕上显示的内容。输入表单应该更新输入字段，单击轮播图上的“下一个”应该更改显示的图片，单击“购买”应该将商品放入购物车。 组件需要“记住”某些东西：当前输入值、当前图片、购物车。 在 React 中，这种组件特有的记忆被称为 state。</p><p>当一个组件需要在多次渲染间“记住”某些信息时使用 state 变量。</p><h3 id="usestate-hook-提供了两个功能" tabindex="-1">useState Hook 提供了两个功能： <a class="header-anchor" href="#usestate-hook-提供了两个功能" aria-label="Permalink to &quot;useState Hook 提供了两个功能：&quot;">​</a></h3><p>State 变量 用于保存渲染间的数据。 State setter 函数 更新变量并触发 React 再次渲染组件。</p><p>如果它们不相关，那么存在多个 state 变量是一个好主意</p><p>但是，如果你发现经常同时更改两个 state 变量，那么最好将它们合并为一个。 例如，如果你有一个包含多个字段的表单，那么有一个值为对象的 state 变量比每个字段对应一个 state 变量更方便。</p><h3 id="state-是隔离且私有的" tabindex="-1">State 是隔离且私有的 <a class="header-anchor" href="#state-是隔离且私有的" aria-label="Permalink to &quot;State 是隔离且私有的&quot;">​</a></h3><p>State 是屏幕上组件实例内部的状态。 换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！ 改变其中一个不会影响另一个。</p><h3 id="两个事件处理函数中均添加了一个保护条件-并在需要时禁用了按钮" tabindex="-1">两个事件处理函数中均添加了一个保护条件，并在需要时禁用了按钮 <a class="header-anchor" href="#两个事件处理函数中均添加了一个保护条件-并在需要时禁用了按钮" aria-label="Permalink to &quot;两个事件处理函数中均添加了一个保护条件，并在需要时禁用了按钮&quot;">​</a></h3><h3 id="state-变量仅用于在组件重渲染时保存信息。" tabindex="-1">State 变量仅用于在组件重渲染时保存信息。 <a class="header-anchor" href="#state-变量仅用于在组件重渲染时保存信息。" aria-label="Permalink to &quot;State 变量仅用于在组件重渲染时保存信息。&quot;">​</a></h3><p>A state variable is only necessary to keep information between re-renders of a component. Within a single event handler, a regular variable will do fine.</p><p>Don’t introduce state variables when a regular variable works well. 在单个事件处理函数中，普通变量就足够了。当普通变量运行良好时，不要引入 state 变量</p><h3 id="state-如同一张快照" tabindex="-1">state 如同一张快照 <a class="header-anchor" href="#state-如同一张快照" aria-label="Permalink to &quot;state 如同一张快照&quot;">​</a></h3><h4 id="设置-state-会触发渲染" tabindex="-1">设置 state 会触发渲染 <a class="header-anchor" href="#设置-state-会触发渲染" aria-label="Permalink to &quot;设置 state 会触发渲染&quot;">​</a></h4><h4 id="渲染会及时生成一张快照" tabindex="-1">渲染会及时生成一张快照 <a class="header-anchor" href="#渲染会及时生成一张快照" aria-label="Permalink to &quot;渲染会及时生成一张快照&quot;">​</a></h4><p>当 React 重新渲染一个组件时：</p><ul><li>React 会再次调用你的函数</li><li>函数会返回新的 JSX 快照</li><li>React 会更新界面以匹配返回的快照</li></ul><p>Setting state only changes it for the next render. 设置 state 只会为下一次渲染变更 state 的值。</p><p>A state variable’s value never changes within a render, even if its event handler’s code is asynchronous. 一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的。</p><p>Its value was “fixed” when React “took the snapshot” of the UI by calling your component. 它的值在 React 通过调用你的组件“获取 UI 的快照”时就被“固定”了。</p><p>React keeps the state values “fixed” within one render’s event handlers. You don’t need to worry whether the state has changed while the code is running. React 会使 state 的值始终”固定“在一次渲染的各个事件处理函数内部。</p><p>Variables and event handlers don’t “survive” re-renders. Every render has its own event handlers. 变量和事件处理函数不会在重渲染中“存活”。每个渲染都有自己的事件处理函数。</p><h3 id="react-会对-state-更新进行批处理" tabindex="-1">React 会对 state 更新进行批处理 <a class="header-anchor" href="#react-会对-state-更新进行批处理" aria-label="Permalink to &quot;React 会对 state 更新进行批处理&quot;">​</a></h3><p>React waits until all code in the event handlers has run before processing your state updates. React 会等到事件处理函数中的 所有 代码都运行完毕再处理你的 state 更新。</p><p>Setting state does not change the variable in the existing render, but it requests a new render. 设置 state 不会更改现有渲染中的变量，但会请求一次新的渲染。</p><h4 id="批处理" tabindex="-1">批处理 <a class="header-anchor" href="#批处理" aria-label="Permalink to &quot;批处理&quot;">​</a></h4><p>React processes state updates after event handlers have finished running. This is called batching. React 在事件处理程序完成运行后处理状态更新。这称为批处理。</p><p>This lets you update multiple state variables—even from multiple components—without triggering too many re-renders. 这让你可以更新多个 state 变量——甚至来自多个组件的 state 变量——而不会触发太多的 重新渲染。</p><p>But this also means that the UI won’t be updated until after your event handler, and any code in it, completes. 但这也意味着只有在你的事件处理函数及其中任何代码执行完成 之后，UI 才会更新。</p><p>This behavior, also known as batching, makes your React app run much faster. 这种特性也就是 批处理，它会使你的 React 应用运行得更快。</p><p>It also avoids dealing with confusing “half-finished” renders where only some of the variables have been updated. 它还会帮你避免处理只更新了一部分 state 变量的令人困惑的“半成品”渲染。</p><p>React does not batch across multiple intentional events like clicks—each click is handled separately. React 不会跨 多个 需要刻意触发的事件（如点击）进行批处理——每次点击都是单独处理的。</p><p>Rest assured that React only does batching when it’s generally safe to do. 请放心，React 只会在一般来说安全的情况下才进行批处理。</p><p>This ensures that, for example, if the first button click disables a form, the second click would not submit it again. 这可以确保，例如，如果第一次点击按钮会禁用表单，那么第二次点击就不会再次提交它。</p><h4 id="更新函数" tabindex="-1">更新函数 <a class="header-anchor" href="#更新函数" aria-label="Permalink to &quot;更新函数&quot;">​</a></h4><p>To update some state multiple times in one event, you can use setNumber(n =&gt; n + 1) updater function. 要在一个事件中多次更新某些状态，可以使用 setNumber(n =&gt; n + 1) 更新程序函数。</p><p>当你将它传递给一个 state 设置函数时：</p><p>React 会将此函数加入队列，以便在事件处理函数中的所有其他代码运行后进行处理。 在下一次渲染期间，React 会遍历队列并给你更新之后的最终 state。</p><blockquote><p>setState(x) 实际上会像 setState(n =&gt; x) 一样运行，只是没有使用 n！</p></blockquote><p>After the event handler completes, React will trigger a re-render. 事件处理函数执行完成后，React 将触发重新渲染。</p><p>During the re-render, React will process the queue. 在重新渲染期间，React 将处理队列。</p><p>Updater functions run during rendering, so updater functions must be pure and only return the result. 更新函数会在渲染期间执行，因此 更新函数必须是 纯函数 并且只 返回 结果。</p><p>Don’t try to set state from inside of them or run other side effects. In Strict Mode, React will run each updater function twice (but discard the second result) to help you find mistakes.</p><p>不要尝试从它们内部设置 state 或者执行其他副作用。 在严格模式下，React 会执行每个更新函数两次（但是丢弃第二个结果）以便帮助你发现错误。</p><h3 id="更新-state-中的对象" tabindex="-1">更新 state 中的对象 <a class="header-anchor" href="#更新-state-中的对象" aria-label="Permalink to &quot;更新 state 中的对象&quot;">​</a></h3><p>你不应该直接修改存放在 React state 中的对象。 相反，当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份），然后将 state 更新为此对象。</p><p>你应该 把所有存放在 state 中的 JavaScript 对象都视为只读的。 你应该把在渲染过程中可以访问到的 state 视为只读的</p><p>为了真正地 触发一次重新渲染，你需要创建一个新对象并把它传递给 state 的设置函数</p><p>对于大型表单，将所有数据都存放在同一个对象中是非常方便的——前提是你能够正确地更新它！</p><p>请注意 ... 展开语法本质是是“浅拷贝”——它只会复制一层。 这使得它的执行速度很快，但是也意味着当你想要更新一个嵌套属性时，你必须得多次使用展开语法。</p><p>请记住，你不应该在 state 中改变对象，包括 Set 中。</p><h4 id="使用-immer-编写简洁的更新逻辑" tabindex="-1">使用 Immer 编写简洁的更新逻辑 <a class="header-anchor" href="#使用-immer-编写简洁的更新逻辑" aria-label="Permalink to &quot;使用 Immer 编写简洁的更新逻辑&quot;">​</a></h4><p>如果你的 state 有多层的嵌套，你或许应该考虑 将其扁平化。但是，如果你不想改变 state 的数据结构，你可能更喜欢用一种更便捷的方式来实现嵌套展开的效果。 Immer 是一个非常流行的库，它可以让你使用简便但可以直接修改的语法编写代码，并会帮你处理好复制的过程。 通过使用 Immer，你写出的代码看起来就像是你“打破了规则”而直接修改了对象</p><h3 id="更新-state-中的数组" tabindex="-1">更新 state 中的数组 <a class="header-anchor" href="#更新-state-中的数组" aria-label="Permalink to &quot;更新 state 中的数组&quot;">​</a></h3><p>在 JavaScript 中，数组只是另一种对象。 同对象一样，你需要将 React state 中的数组视为只读的。 这意味着你不应该使用类似于 <code>arr[0] = &#39;bird&#39;</code> 这样的方式来重新分配数组中的元素，也不应该使用会直接修改原始数组的方法，例如 push() 和 pop()。</p><p>相反，每次要更新一个数组时，你需要把一个新的数组传入 state 的 setting 方法中。 为此，你可以通过使用像 filter() 和 map() 这样不会直接修改原始值的方法，从原始数组生成一个新的数组。然后你就可以将 state 设置为这个新生成的数组。</p><h4 id="虽然-slice-和-splice-的名字相似-但作用却迥然不同" tabindex="-1">虽然 slice 和 splice 的名字相似，但作用却迥然不同 <a class="header-anchor" href="#虽然-slice-和-splice-的名字相似-但作用却迥然不同" aria-label="Permalink to &quot;虽然 slice 和 splice 的名字相似，但作用却迥然不同&quot;">​</a></h4><p>slice 让你可以拷贝数组或是数组的一部分。 splice 会直接修改 原始数组（插入或者删除元素）。</p><p>在 React 中，更多情况下你会使用 slice（没有 p ！），因为你不想改变 state 中的对象或数组。</p><p>即使你拷贝了数组，你还是不能直接修改其内部的元素。 这是因为数组的拷贝是浅拷贝——新的数组中依然保留了与原始数组相同的元素。 因此，如果你修改了拷贝数组内部的某个对象，其实你正在直接修改当前的 state。</p><h2 id="使用-hooks" tabindex="-1">使用 Hooks <a class="header-anchor" href="#使用-hooks" aria-label="Permalink to &quot;使用 Hooks&quot;">​</a></h2><p>Hooks are more restrictive than other functions. You can only call Hooks at the top of your components (or other Hooks). If you want to use useState in a condition or a loop, extract a new component and put it there.</p><p>钩子比其他函数更具限制性。您只能调用组件顶部的 Hooks（或其他 Hook）。 <strong>如果要在条件或循环中使用 useState ，请提取一个新组件并将其放在那里</strong>。</p><p>Hooks are special functions that are only available while React is rendering Hook 是特殊的函数，只在 React 渲染时有效</p><p>Hooks—functions starting with use—can only be called at the top level of your components or your own Hooks. You can’t call Hooks inside conditions, loops, or other nested functions.</p><p>Hooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。</p><p>Hooks are functions, but it’s helpful to think of them as unconditional declarations about your component’s needs. You “use” React features at the top of your component similar to how you “import” modules at the top of your file.</p><p>Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。 在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。</p><h2 id="提升状态-lifting-state-up" tabindex="-1">提升状态 “lifting state up” <a class="header-anchor" href="#提升状态-lifting-state-up" aria-label="Permalink to &quot;提升状态 “lifting state up”&quot;">​</a></h2><p>By moving state up, you’ve shared it between components. 通过向上移动状态，您可以在组件之间共享它</p><p>To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with their parent.</p><p>若要从多个子组件收集数据，或者让两个子组件相互通信，请改为在其父组件中声明共享状态。 父组件可以通过 props 将该状态传递回子组件。 这使子组件彼此之间以及与父组件保持同步。</p><p>Lifting state into a parent component is common when React components are refactored. 在重构 React 组件时，将状态提升到父组件是很常见的。</p><h3 id="单向数据流-one-way-data-flow" tabindex="-1">单向数据流 one-way data flow <a class="header-anchor" href="#单向数据流-one-way-data-flow" aria-label="Permalink to &quot;单向数据流 one-way data flow&quot;">​</a></h3><p>This is called one-way data flow because the data flows down from the top-level component to the ones at the bottom of the tree. 因为数据从顶层组件向向树底部的组件。</p><h2 id="return-意味着后面的任何内容都作为值返回给函数的调用方" tabindex="-1">return 意味着后面的任何内容都作为<em>值</em>返回给函数的调用方 <a class="header-anchor" href="#return-意味着后面的任何内容都作为值返回给函数的调用方" aria-label="Permalink to &quot;return 意味着后面的任何内容都作为*值*返回给函数的调用方&quot;">​</a></h2><p>The return JavaScript keyword means whatever comes after is returned as a value to the caller of the function. JavaScript 关键字 <strong>return</strong> 意味着后面的任何内容都作为<em>值</em>返回给函数的调用方。</p><p>React 组件需要返回单个 JSX 元素 您可以使用 Fragments （ <code>&lt;&gt; 和 &lt;/&gt;</code> ） 来包装多个相邻的 JSX 元素</p><blockquote><p>如果你的标签和 return 关键字不在同一行，则必须把它包裹在一对括号中 没有括号包裹的话，任何在 return 下一行的代码都 将被忽略！</p></blockquote><h2 id="react-dom-client" tabindex="-1">react-dom/client <a class="header-anchor" href="#react-dom-client" aria-label="Permalink to &quot;react-dom/client&quot;">​</a></h2><p>React’s library to talk to web browsers (React DOM) 用于与 Web 浏览器对话的 React 库 （React DOM）</p><h2 id="函数闭包-closures" tabindex="-1">函数闭包 closures <a class="header-anchor" href="#函数闭包-closures" aria-label="Permalink to &quot;函数闭包 closures&quot;">​</a></h2><p>JavaScript supports <strong>closures</strong> which means an inner function (e.g. handleClick) has access to variables and functions defined in a outer function (e.g. Board). JavaScript 支持<strong>闭包</strong>，这意味着内部函数（例如 handleClick ）可以访问外部函数（例如 ）中定义的变量和函数 Board</p><h2 id="不变性很重要-immutability-is-important" tabindex="-1">不变性很重要 immutability is important <a class="header-anchor" href="#不变性很重要-immutability-is-important" aria-label="Permalink to &quot;不变性很重要  immutability is important&quot;">​</a></h2><p>调用 <code>.slice()</code> 以创建 squares 数组的副本，而不是修改现有数组。</p><p>通常有两种方法可以更改数据。 第一种方法是通过直接更改数据的值来改变数据。 第二种方法是将数据替换为具有所需更改的新副本。</p><p>The result is the same but by not mutating (changing the underlying data) directly, you gain several benefits. 结果是相同的，但通过不直接变异（更改基础数据），您可以获得一些好处。</p><h3 id="不直接变异的好处" tabindex="-1">不直接变异的好处 <a class="header-anchor" href="#不直接变异的好处" aria-label="Permalink to &quot;不直接变异的好处&quot;">​</a></h3><ol><li><p>不可变性使复杂的功能更容易实现</p><p>Avoiding direct data mutation lets you keep previous versions of the data intact, and reuse them later. 通过避免直接数据突变，您可以保持以前版本的数据不变，并在以后重复使用它们。</p></li><li><p>不可变性使得组件比较其数据是否已更改的成本非常低</p><p>By default, all child components re-render automatically when the state of a parent component changes. This includes even the child components that weren’t affected by the change. Although re-rendering is not by itself noticeable to the user (you shouldn’t actively try to avoid it!), you might want to skip re-rendering a part of the tree that clearly wasn’t affected by it for performance reasons. Immutability makes it very cheap for components to compare whether their data has changed or not. 不变性还有另一个好处。默认情况下，当父组件的状态发生更改时，所有子组件都会自动重新渲染。这甚至包括不受更改影响的子组件。 尽管重新渲染本身对用户来说并不明显（你不应该主动尝试避免它！），但出于性能原因，你可能希望跳过重新渲染树中明显不受其影响的部分。</p></li></ol><h2 id="react组件化开发思维" tabindex="-1">React组件化开发思维 <a class="header-anchor" href="#react组件化开发思维" aria-label="Permalink to &quot;React组件化开发思维&quot;">​</a></h2><h3 id="react-组件定义" tabindex="-1">React 组件定义 <a class="header-anchor" href="#react-组件定义" aria-label="Permalink to &quot;React 组件定义&quot;">​</a></h3><p>a React component is a JavaScript function that you can sprinkle with markup React 组件是一段可以 使用标签进行扩展 的 JavaScript 函数</p><p>React components are regular JavaScript functions except: React 组件是常规的 JavaScript 函数，除了：</p><p>Their names always begin with a capital letter. 他们的名字总是以大写字母开头。[] They return JSX markup. 它们返回 JSX 标记。</p><p>Components are a handy way to organize UI code and markup, even if some of them are only used once. 组件是组织 UI 代码和标签的一种快捷方式，即使其中一些组件只使用了一次。</p><p>in a React app, every piece of UI is a component. 在 React 应用程序中，每一个 UI 模块都是一个组件，万物皆组件。</p><blockquote><p>React 组件是常规的 JavaScript 函数，但 组件的名称必须以大写字母开头，否则它们将无法运行！ 组件可以渲染其他组件，但是 请不要嵌套他们的定义, 因为这样非常慢，并且会导致 bug 产生。因此，你应该在顶层定义每个组件 当子组件需要使用父组件的数据时，你需要 通过 props 的形式进行传递，而不是嵌套定义。 你在相同位置渲染的是 不同 的组件，所以 React 将其下所有的 state 都重置了。 这样会导致 bug 以及性能问题。为了避免这个问题， 永远要将组件定义在最上层并且不要把它们的定义嵌套起来。 <a href="https://react.docschina.org/learn/preserving-and-resetting-state#different-components-at-the-same-position-reset-state" target="_blank" rel="noreferrer">https://react.docschina.org/learn/preserving-and-resetting-state#different-components-at-the-same-position-reset-state</a></p></blockquote><h3 id="步骤-1-将-ui-分解为组件层次结构" tabindex="-1">步骤 1：将 UI 分解为组件层次结构 <a class="header-anchor" href="#步骤-1-将-ui-分解为组件层次结构" aria-label="Permalink to &quot;步骤 1：将 UI 分解为组件层次结构&quot;">​</a></h3><p>Step 1: Break the UI into a component hierarchy</p><p>If your JSON is well-structured, you’ll often find that it naturally maps to the component structure of your UI. That’s because UI and data models often have the same information architecture—that is, the same shape. Separate your UI into components, where each component matches one piece of your data model.</p><p>如果你的 JSON 结构良好，你通常会发现它自然地映射到 UI 的组件结构。 这是因为 UI 和数据模型通常具有相同的信息体系结构，即相同的形状。 将 UI 分成多个组件，其中每个组件与数据模型的一部分匹配。</p><h3 id="第-2-步-在-react-中构建静态版本" tabindex="-1">第 2 步：在 React 中构建静态版本 <a class="header-anchor" href="#第-2-步-在-react-中构建静态版本" aria-label="Permalink to &quot;第 2 步：在 React 中构建静态版本&quot;">​</a></h3><p>Step 2: Build a static version in React The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity… yet! 最直接的方法是构建一个版本，该版本从数据模型呈现 UI，而无需添加任何交互性......是的！</p><h4 id="先不要使用交互-不需要使用事件处理函数" tabindex="-1">先不要使用交互，不需要使用事件处理函数 <a class="header-anchor" href="#先不要使用交互-不需要使用事件处理函数" aria-label="Permalink to &quot;先不要使用交互，不需要使用事件处理函数&quot;">​</a></h4><p>It’s often easier to build the static version first and add interactivity later. Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing. 先构建静态版本，然后再添加交互性通常更容易。 构建静态版本需要大量的打字，不需要思考，但添加交互性需要大量的思考，而不是大量的打字。</p><p>To build a static version of your app that renders your data model, you’ll want to build components that reuse other components and pass data using props. Props are a way of passing data from parent to child.</p><p>若要生成呈现数据模型的应用的静态版本，需要构建可重用其他组件并使用 prop 传递数据的组件。 Props是一种将数据从父级传递到子级的方式。</p><h4 id="先不要使用state" tabindex="-1">先不要使用state <a class="header-anchor" href="#先不要使用state" aria-label="Permalink to &quot;先不要使用state&quot;">​</a></h4><p>(If you’re familiar with the concept of state, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it.) （如果你熟悉状态的概念，请不要使用状态来构建这个静态版本。 状态仅保留用于交互性，即随时间变化的数据。 由于这是应用程序的静态版本，因此您不需要它。）</p><h4 id="在较大的项目中-自下而上构建组件更容易" tabindex="-1">在较大的项目中，自下而上构建组件更容易 <a class="header-anchor" href="#在较大的项目中-自下而上构建组件更容易" aria-label="Permalink to &quot;在较大的项目中，自下而上构建组件更容易&quot;">​</a></h4><p>您可以“自上而下”地构建，首先在层次结构中构建较高的组件，也可以通过从较低的组件开始“自下而上”地构建。</p><p>在更简单的例子中，自上而下通常更容易，而在较大的项目中，自下而上更容易。</p><h3 id="步骤-3-查找-ui-状态的最小但完整的表示形式" tabindex="-1">步骤 3：查找 UI 状态的最小但完整的表示形式 <a class="header-anchor" href="#步骤-3-查找-ui-状态的最小但完整的表示形式" aria-label="Permalink to &quot;步骤 3：查找 UI 状态的最小但完整的表示形式&quot;">​</a></h3><p>Step 3: Find the minimal but complete representation of UI state。</p><p>To make the UI interactive, you need to let users change your underlying data model. You will use state for this. 若要使 UI 具有交互性，需要允许用户更改基础数据模型。为此，您将使用 state。</p><p>Think of state as the minimal set of changing data that your app needs to remember. The most important principle for structuring state is to keep it DRY (Don’t Repeat Yourself). Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand.</p><p>将状态视为应用需要记住的最小更改数据集。构建状态的最重要原则是保持干燥（不要重复自己）。 找出应用程序所需状态的绝对最小表示，并按需计算其他所有内容。</p><p>For example, if you’re building a shopping list, you can store the items as an array in state. If you want to also display the number of items in the list, don’t store the number of items as another state value—instead, read the length of your array.</p><p>例如，如果您正在构建购物清单，则可以将项目存储为状态中的数组。 如果还想显示列表中的项数，请不要将项数存储为另一个状态值，而是读取数组的长度</p><h3 id="第-4-步-确定您的state应该放在哪里" tabindex="-1">第 4 步：确定您的state应该放在哪里 <a class="header-anchor" href="#第-4-步-确定您的state应该放在哪里" aria-label="Permalink to &quot;第 4 步：确定您的state应该放在哪里&quot;">​</a></h3><p>Step 4: Identify where your state should live</p><p>After identifying your app’s minimal state data, you need to identify which component is responsible for changing this state, or owns the state. Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component. 确定应用的最小状态数据后，需要确定哪个组件负责更改此状态，或者哪个组件拥有该状态。 请记住：React 使用单向数据流，将数据从父组件向下传递到子组件。</p><h4 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h4><p>为你应用程序中的每一个 state:</p><ul><li>验证每一个基于特定 state 渲染的组件。</li><li>找它们最近并且共同的父组件——在层级结构中，一个凌驾于它们所有组件之上的组件。</li><li>决定 state 应该被放置于哪里: <ul><li>通常情况下，你可以直接放置 state 于它们共同的父组件。</li><li>你也可以将 state 放置于它们父组件上层的组件。</li><li>如果你找不到一个有意义拥有这个 state 的地方，单独创建一个新的组件去管理这个 state，并将它添加到它们父组件上层的某个地方。</li></ul></li></ul><p>总是一起出现的东西，将它们放在同一个位置是有意义的。</p><h3 id="步骤-5-添加反向数据流" tabindex="-1">步骤 5：添加反向数据流 <a class="header-anchor" href="#步骤-5-添加反向数据流" aria-label="Permalink to &quot;步骤 5：添加反向数据流&quot;">​</a></h3><p>Step 5: Add inverse data flow</p><h3 id="组件的导入导出" tabindex="-1">组件的导入导出 <a class="header-anchor" href="#组件的导入导出" aria-label="Permalink to &quot;组件的导入导出&quot;">​</a></h3><p>通常，文件中仅包含一个组件时，人们会选择默认导出，而当文件中包含多个组件或某个值需要导出时，则会选择具名导出。 无论选择哪种方式，请记得给你的组件和相应的文件命名一个有意义的名字。 我们不建议创建未命名的组件，比如 <code>export default () =&gt; {}</code>，因为这样会使得调试变得异常困难。</p><h2 id="props" tabindex="-1">Props <a class="header-anchor" href="#props" aria-label="Permalink to &quot;Props&quot;">​</a></h2><h3 id="给-prop-指定一个默认值" tabindex="-1">给 prop 指定一个默认值 <a class="header-anchor" href="#给-prop-指定一个默认值" aria-label="Permalink to &quot;给 prop 指定一个默认值&quot;">​</a></h3><p>默认值仅在<code>缺少 size</code> prop 或 <code>size={undefined}</code> 时生效。 但是如果你传递了 <code>size={null} </code>或 <code>size={0}</code>，默认值将 不 被使用。</p><h3 id="请克制地使用展开语法。" tabindex="-1">请克制地使用展开语法。 <a class="header-anchor" href="#请克制地使用展开语法。" aria-label="Permalink to &quot;请克制地使用展开语法。&quot;">​</a></h3><p>如果你在所有其他组件中都使用它，那就有问题了。 通常，它表示你应该拆分组件，并将子组件作为 JSX 传递。</p><h3 id="将-jsx-作为子组件传递" tabindex="-1">将 JSX 作为子组件传递 <a class="header-anchor" href="#将-jsx-作为子组件传递" aria-label="Permalink to &quot;将 JSX 作为子组件传递&quot;">​</a></h3><p>可以将带有 children prop 的组件看作有一个“洞”，可以由其父组件使用任意 JSX 来“填充”。 你会经常使用 children prop 来进行视觉包装：面板、网格等等。</p><p>Any JSX you put inside of a component’s tag will be passed as the children prop to that component. 放入组件标签内的任何 JSX 都将作为 children prop 传递给该组件。</p><h3 id="props-并不总是静态的" tabindex="-1">Props 并不总是静态的！ <a class="header-anchor" href="#props-并不总是静态的" aria-label="Permalink to &quot;Props 并不总是静态的！&quot;">​</a></h3><p>一个组件可能会随着时间的推移收到不同的 props。</p><p>然而，props 是 不可变的（一个计算机科学术语，意思是“不可改变”）。 当一个组件需要改变它的 props（例如，响应用户交互或新数据）时，它不得不“请求”它的父组件传递 不同的 props —— 一个新对象！ 它的旧 props 将被丢弃，最终 JavaScript 引擎将回收它们占用的内存。</p><p>Props are read-only snapshots in time: every render receives a new version of props. Props 是只读的时间快照：每次渲染都会收到新版本的 props。</p><h3 id="你不能改变-props。当你需要交互性时-你可以设置-state。" tabindex="-1">你不能改变 props。当你需要交互性时，你可以设置 state。 <a class="header-anchor" href="#你不能改变-props。当你需要交互性时-你可以设置-state。" aria-label="Permalink to &quot;你不能改变 props。当你需要交互性时，你可以设置 state。&quot;">​</a></h3><p>You can’t change props. When you need interactivity, you’ll need to set state. 不要尝试“更改 props”。 当你需要响应用户输入（例如更改所选颜色）时，你可以“设置 state”</p><h2 id="保持组件纯粹-keeping-components-pure" tabindex="-1">保持组件纯粹 Keeping Components Pure <a class="header-anchor" href="#保持组件纯粹-keeping-components-pure" aria-label="Permalink to &quot;保持组件纯粹 Keeping Components Pure&quot;">​</a></h2><p>In computer science (and especially the world of functional programming), a pure function is a function with the following characteristics: 在计算机科学中（尤其是函数式编程的世界中），纯函数 通常具有如下特征：</p><p>It minds its own business. It does not change any objects or variables that existed before it was called. 只负责自己的任务。它不会更改在该函数调用前就已存在的对象或变量。</p><p>Same inputs, same output. Given the same inputs, a pure function should always return the same result. 输入相同，则输出相同。给定相同的输入，纯函数应总是返回相同的结果。</p><p>React is designed around this concept. React assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs React 就是围绕这个概念设计的。 React 假设你编写的每个组件都是一个纯函数。 这意味着你编写的 React 组件必须始终返回相同的 JSX，给定相同的输入</p><p>each component should only “think for itself”, and not attempt to coordinate with or depend upon others during rendering. 每个组件都应该“独立思考”，而不是在渲染过程中试图与其他组件协调或依赖其他组件</p><h4 id="使用-strictmode-检测不纯计算" tabindex="-1">使用 StrictMode 检测不纯计算 <a class="header-anchor" href="#使用-strictmode-检测不纯计算" aria-label="Permalink to &quot;使用 StrictMode 检测不纯计算&quot;">​</a></h4><p>Detecting impure calculations with StrictMode</p><h3 id="可能引起副作用的地方" tabindex="-1">可能引起副作用的地方 <a class="header-anchor" href="#可能引起副作用的地方" aria-label="Permalink to &quot;可能引起副作用的地方&quot;">​</a></h3><p>Where you can cause side effects</p><p>Rendering is a calculation, it shouldn’t try to “do” things 渲染是一种 计算过程 ，它不应该试图“做”其他事情。</p><p>Remember that React does not guarantee that component functions will execute in any particular order, so you can’t communicate between them by setting variables. All communication must happen through props. React 无法保证组件函数以任何特定的顺序执行，因此你无法通过设置变量在它们之间进行通信。所有的交流都必须通过 props 进行。</p><p>It is useful to remember which operations on arrays mutate them, and which don’t. For example, push, pop, reverse, and sort will mutate the original array, but slice, filter, and map will create a new one. 记住数组上的哪些操作会修改原始数组、哪些不会，这非常有帮助。 例如，push、pop、reverse 和 sort 会改变原始数组，但 slice、filter 和 map 则会创建一个新数组。</p><h4 id="副作用的定义" tabindex="-1">副作用的定义 <a class="header-anchor" href="#副作用的定义" aria-label="Permalink to &quot;副作用的定义&quot;">​</a></h4><p>While functional programming relies heavily on purity, at some point, somewhere, something has to change. That’s kind of the point of programming! These changes—updating the screen, starting an animation, changing the data—are called side effects. They’re things that happen “on the side”, not during rendering. 虽然函数式编程在很大程度上依赖于纯度，但在某些时候，某个地方，有些东西必须改变。 这就是编程的意义所在！这些更改（更新屏幕、启动动画、更改数据）称为<strong>副作用</strong>。 它们是“额外”发生的事情，而不是在渲染过程中发生的。</p><h4 id="事件处理程序无需是纯函数" tabindex="-1">事件处理程序无需是纯函数 <a class="header-anchor" href="#事件处理程序无需是纯函数" aria-label="Permalink to &quot;事件处理程序无需是纯函数&quot;">​</a></h4><p>In React, side effects usually belong inside event handlers. Event handlers are functions that React runs when you perform some action—for example, when you click a button. Even though event handlers are defined inside your component, they don’t run during rendering! So event handlers don’t need to be pure. 在 React 中，副作用通常属于事件处理程序。 事件处理程序是 React 在执行某些操作（例如，单击按钮时）运行的函数。 即使事件处理程序在组件中定义，它们也不会在渲染期间运行！ 因此，事件处理程序不需要是纯粹的。</p><p>If you’ve exhausted all other options and can’t find the right event handler for your side effect, you can still attach it to your returned JSX with a useEffect call in your component. This tells React to execute it later, after rendering, when side effects are allowed. However, this approach should be your last resort. 如果您已经用尽了所有其他选项，并且找不到适合您的副作用的事件处理程序，您仍然可以通过在组件中 useEffect 调用将其附加到返回的 JSX。 这告诉 React 稍后在渲染后，当允许副作用时执行它。 但是，这种方法应该是您最后的手段。</p><p>When possible, try to express your logic with rendering alone. You’ll be surprised how far this can take you! 如果可能的话，尝试仅用渲染来表达你的逻辑。 你会惊讶于这能带你走多远！</p><h4 id="react-为何侧重于纯函数" tabindex="-1">React 为何侧重于纯函数? <a class="header-anchor" href="#react-为何侧重于纯函数" aria-label="Permalink to &quot;React 为何侧重于纯函数?&quot;">​</a></h4><p>Why does React care about purity?</p><p>编写纯函数需要遵循一些习惯和规程。但它开启了绝妙的机遇：</p><p>你的组件可以在不同的环境下运行 — 例如，在服务器上！由于它们针对相同的输入，总是返回相同的结果，因此一个组件可以满足多个用户请求。</p><p>你可以为那些输入未更改的组件来 跳过渲染，以提高性能。这是安全的做法，因为纯函数总是返回相同的结果，所以可以安全地缓存它们。</p><p>如果在渲染深层组件树的过程中，某些数据发生了变化，React 可以重新开始渲染，而不会浪费时间完成过时的渲染。纯粹性使得它随时可以安全地停止计算。</p><p>From data fetching to animations to performance, keeping components pure unlocks the power of the React paradigm. 从数据获取到动画再到性能，保持组件的纯性可以释放 React 范式的力量。</p><h2 id="渲染和提交" tabindex="-1">渲染和提交 <a class="header-anchor" href="#渲染和提交" aria-label="Permalink to &quot;渲染和提交&quot;">​</a></h2><p>Before your components are displayed on screen, they must be rendered by React. 组件显示到屏幕之前，其必须被 React 渲染。</p><p>在一个 React 应用中,一次屏幕更新都会发生以下三个步骤： 触发 渲染 提交</p><h3 id="步骤-1-触发一次渲染" tabindex="-1">步骤 1: 触发一次渲染 <a class="header-anchor" href="#步骤-1-触发一次渲染" aria-label="Permalink to &quot;步骤 1: 触发一次渲染&quot;">​</a></h3><p>There are two reasons for a component to render: 有两种原因会导致组件的渲染:</p><p>It’s the component’s initial render. 组件的 初次渲染。</p><p>The component’s (or one of its ancestors’) state has been updated. 组件（或者其祖先之一）的 状态发生了改变。</p><h4 id="initial-render-初始渲染" tabindex="-1">Initial render 初始渲染 <a class="header-anchor" href="#initial-render-初始渲染" aria-label="Permalink to &quot;Initial render  初始渲染&quot;">​</a></h4><p>When your app starts, you need to trigger the initial render. Frameworks and sandboxes sometimes hide this code, but it’s done by calling <code>createRoot</code> with the target DOM node, and then calling its <code>render</code> method with your component 当应用启动时，会触发初次渲染。 框架和沙箱有时会隐藏这部分代码，但它是通过调用目标 DOM 节点的 <code>createRoot</code>，然后用你的组件调用 <code>render</code> 函数完成的</p><h4 id="re-renders-when-state-updates-状态更新时重新渲染" tabindex="-1">Re-renders when state updates 状态更新时重新渲染 <a class="header-anchor" href="#re-renders-when-state-updates-状态更新时重新渲染" aria-label="Permalink to &quot;Re-renders when state updates 状态更新时重新渲染&quot;">​</a></h4><p>Once the component has been initially rendered, you can trigger further renders by updating its state with the set function.</p><p>Updating your component’s state automatically queues a render. 一旦组件被初次渲染，你就可以通过使用 set 函数 更新其状态来触发之后的渲染。 更新组件的状态会自动将一次渲染送入队列。</p><h3 id="步骤-2-react-渲染你的组件" tabindex="-1">步骤 2: React 渲染你的组件 <a class="header-anchor" href="#步骤-2-react-渲染你的组件" aria-label="Permalink to &quot;步骤 2: React 渲染你的组件&quot;">​</a></h3><p>After you trigger a render, React calls your components to figure out what to display on screen. “Rendering” is React calling your components. 在你触发渲染后，React 会调用你的组件来确定要在屏幕上显示的内容。 “渲染中” 即 React 在调用你的组件。</p><p>On initial render, React will call the root component. 在进行初次渲染时, React 会调用根组件。</p><p>For subsequent renders, React will call the function component whose state update triggered the render. 对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。</p><p>这个过程是递归的： 如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染 那个 组件，而如果那个组件又返回了某个组件，那么 React 接下来就会渲染 那个 组件，以此类推。 这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止。</p><p>Rendering must always be a pure calculation: 渲染必须始终是纯计算：</p><p>Same inputs, same output. Given the same inputs, a component should always return the same JSX. 相同的输入，相同的输出。给定相同的输入，组件应始终返回相同的 JSX。</p><p>It minds its own business. It should not change any objects or variables that existed before rendering. 它只关心自己的事情。它不应更改渲染之前存在的任何对象或变量。</p><p>Otherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. When developing in “Strict Mode”, React calls each component’s function twice, which can help surface mistakes caused by impure functions.</p><p>否则，随着代码库复杂性的增加，你可能会遇到令人困惑的错误和不可预测的行为。 在 “严格模式” 下开发时，React 会调用每个组件的函数两次，这可以帮助发现由不纯函数引起的错误。</p><h4 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h4><p>The default behavior of rendering all components nested within the updated component is not optimal for performance if the updated component is very high in the tree. 如果更新的组件在树中的位置非常高，渲染更新后的组件内部所有嵌套组件的默认行为将不会获得最佳性能。</p><p>Don’t optimize prematurely! 不要过早进行优化！</p><h3 id="第-3-步-react-提交对-dom-的更改" tabindex="-1">第 3 步：React 提交对 DOM 的更改 <a class="header-anchor" href="#第-3-步-react-提交对-dom-的更改" aria-label="Permalink to &quot;第 3 步：React 提交对 DOM 的更改&quot;">​</a></h3><p>在渲染（调用）你的组件之后，React 将会修改 DOM</p><p>对于初次渲染， React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。 对于重渲染， React 将应用最少的必要操作（在渲染时计算！），以使得 DOM 与最新的渲染输出相互匹配。</p><p>React only changes the DOM nodes if there’s a difference between renders. React 仅在渲染之间存在差异时才会更改 DOM 节点。</p><p>For example, here is a component that re-renders with different props passed from its parent every second. 例如，有一个组件，它每秒使用从父组件传递下来的不同属性重新渲染一次。</p><h3 id="尾声-浏览器绘制" tabindex="-1">尾声：浏览器绘制 <a class="header-anchor" href="#尾声-浏览器绘制" aria-label="Permalink to &quot;尾声：浏览器绘制&quot;">​</a></h3><p>After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as “browser rendering”, we’ll refer to it as “painting”</p><p>在渲染完成并且 React 更新 DOM 之后，浏览器就会重新绘制屏幕。 尽管这个过程被称为“浏览器渲染”（“browser rendering”），但我们还是将它称为“绘制”（“painting”）</p><h2 id="状态管理-managing-state" tabindex="-1">状态管理 Managing State <a class="header-anchor" href="#状态管理-managing-state" aria-label="Permalink to &quot;状态管理 Managing State&quot;">​</a></h2><p>Redundant or duplicate state is a common source of bugs. 冗余或重复的状态往往是缺陷的根源</p><p>React provides a declarative way to manipulate the UI. React 控制 UI 的方式是声明式的。</p><p>Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. 你不必直接控制 UI 的各个部分，只需要声明组件可以处于的不同状态，并根据用户的输入在它们之间切换。</p><h3 id="声明式地考虑-ui" tabindex="-1">声明式地考虑 UI <a class="header-anchor" href="#声明式地考虑-ui" aria-label="Permalink to &quot;声明式地考虑 UI&quot;">​</a></h3><h4 id="步骤-1-定位组件中不同的视图状态" tabindex="-1">步骤 1：定位组件中不同的视图状态 <a class="header-anchor" href="#步骤-1-定位组件中不同的视图状态" aria-label="Permalink to &quot;步骤 1：定位组件中不同的视图状态&quot;">​</a></h4><h5 id="同时展示大量的视图状态" tabindex="-1">同时展示大量的视图状态 <a class="header-anchor" href="#同时展示大量的视图状态" aria-label="Permalink to &quot;同时展示大量的视图状态&quot;">​</a></h5><p>如果一个组件有多个视图状态，你可以很方便地将它们展示在一个页面中， 类似这样的页面通常被称作“living styleguide”或“storybook”。</p><h4 id="步骤-2-确定是什么触发了这些状态的改变" tabindex="-1">步骤 2：确定是什么触发了这些状态的改变 <a class="header-anchor" href="#步骤-2-确定是什么触发了这些状态的改变" aria-label="Permalink to &quot;步骤 2：确定是什么触发了这些状态的改变&quot;">​</a></h4><p>你可以触发 state 的更新来响应两种输入：</p><p>人为输入。比如点击按钮、在表单中输入内容，或导航到链接。 计算机输入。比如网络请求得到反馈、定时器被触发，或加载一张图片。</p><p>以上两种情况中，你必须设置 state 变量 去更新 UI</p><blockquote><p>注意，人为输入通常需要 事件处理函数！</p></blockquote><h5 id="可视化流程状态" tabindex="-1">可视化流程状态 <a class="header-anchor" href="#可视化流程状态" aria-label="Permalink to &quot;可视化流程状态&quot;">​</a></h5><p>为了可视化这个流程，请尝试在纸上画出圆形标签以表示每个状态，两个状态之间的改变用箭头表示。 你可以像这样画出很多流程并且在写代码前解决许多 bug。</p><h4 id="步骤-3-通过-usestate-表示内存中的-state" tabindex="-1">步骤 3：通过 useState 表示内存中的 state <a class="header-anchor" href="#步骤-3-通过-usestate-表示内存中的-state" aria-label="Permalink to &quot;步骤 3：通过 useState 表示内存中的 state&quot;">​</a></h4><p>接下来你会需要在内存中通过 useState 表示组件中的视图状态。 诀窍很简单：state 的每个部分都是“处于变化中的”，并且你需要让“变化的部分”尽可能的少。 更复杂的程序会产生更多 bug！ 先从绝对必须存在的状态开始。</p><p>如果你很难立即想出最好的办法，那就先从添加足够多的 state 开始，确保所有可能的视图状态都囊括其中 你最初的想法或许不是最好的，但是没关系，重构 state 也是步骤中的一部分！</p><h4 id="步骤-4-删除任何不必要的-state-变量" tabindex="-1">步骤 4：删除任何不必要的 state 变量 <a class="header-anchor" href="#步骤-4-删除任何不必要的-state-变量" aria-label="Permalink to &quot;步骤 4：删除任何不必要的 state 变量&quot;">​</a></h4><p>你会想要避免 state 内容中的重复，从而只需要关注那些必要的部分。 花一点时间来重构你的 state 结构，会让你的组件更容易被理解，减少重复并且避免歧义。 你的目的是防止出现在内存中的 state 不代表任何你希望用户看到的有效 UI 的情况。 （比如你绝对不会想要在展示错误信息的同时禁用掉输入框，导致用户无法纠正错误！）</p><h5 id="这有一些你可以问自己的-关于-state-变量的问题" tabindex="-1">这有一些你可以问自己的， 关于 state 变量的问题： <a class="header-anchor" href="#这有一些你可以问自己的-关于-state-变量的问题" aria-label="Permalink to &quot;这有一些你可以问自己的， 关于 state 变量的问题：&quot;">​</a></h5><p>这个 state 是否会导致矛盾？ 相同的信息是否已经在另一个 state 变量中存在？ 你是否可以通过另一个 state 变量的相反值得到相同的信息？</p><blockquote><p>通过 reducer 来减少“不可能” state 为了更精确地模块化状态，你可以 将状态提取到一个 reducer 中。 Reducer 可以让您合并多个状态变量到一个对象中并巩固所有相关的逻辑！</p></blockquote><h4 id="步骤-5-连接事件处理函数以设置-state" tabindex="-1">步骤 5：连接事件处理函数以设置 state <a class="header-anchor" href="#步骤-5-连接事件处理函数以设置-state" aria-label="Permalink to &quot;步骤 5：连接事件处理函数以设置 state&quot;">​</a></h4><p>最后，创建事件处理函数去设置 state 变量</p><p>尽管这些代码相对与最初的命令式的例子来说更长，但是却更加健壮。 将所有的交互变为 state 的改变，可以让你避免之后引入新的视图状态后导致现有 state 被破坏。 同时也使你在不必改变交互逻辑的情况下，更改每个状态对应的 UI。</p><h3 id="选择状态结构" tabindex="-1">选择状态结构 <a class="header-anchor" href="#选择状态结构" aria-label="Permalink to &quot;选择状态结构&quot;">​</a></h3><p>Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. 良好的状态组织，可以区分开易于修改和调试的组件与频繁出问题的组件。</p><p>The most important principle is that state shouldn’t contain redundant or duplicated information. 最重要的原则是，状态不应包含冗余或重复的信息。</p><p>If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs! 如果包含一些多余的状态，我们会很容易忘记去更新它，从而导致问题产生！</p><h4 id="构建-state-的原则" tabindex="-1">构建 state 的原则 <a class="header-anchor" href="#构建-state-的原则" aria-label="Permalink to &quot;构建 state 的原则&quot;">​</a></h4><p>当你编写一个存有 state 的组件时，你需要选择使用多少个 state 变量以及它们都是怎样的数据格式。 尽管选择次优的 state 结构下也可以编写正确的程序，但有几个原则可以指导您做出更好的决策：</p><h5 id="合并关联的-state。" tabindex="-1">合并关联的 state。 <a class="header-anchor" href="#合并关联的-state。" aria-label="Permalink to &quot;合并关联的 state。&quot;">​</a></h5><p>Group related state.</p><p>If you always update two or more state variables at the same time, consider merging them into a single state variable. 如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。</p><p>如果你的 state 变量是一个对象时，请记住，你不能只更新其中的一个字段 而不显式复制其他字段。</p><h5 id="避免互相矛盾的-state。" tabindex="-1">避免互相矛盾的 state。 <a class="header-anchor" href="#避免互相矛盾的-state。" aria-label="Permalink to &quot;避免互相矛盾的 state。&quot;">​</a></h5><p>Avoid contradictions in state.</p><p>When the state is structured in a way that several pieces of state may contradict and “disagree” with each other, you leave room for mistakes. Try to avoid this. 当 state 结构中存在多个相互矛盾或“不一致”的 state 时，你就可能为此会留下隐患。应尽量避免这种情况。</p><p>你仍然可以声明一些常量，以提高可读性：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> isSending</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> status</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> &#39;sending&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> isSent</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> status</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> &#39;sent&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>但它们不是 state 变量，所以你不必担心它们彼此失去同步。</p><h5 id="避免冗余的-state。" tabindex="-1">避免冗余的 state。 <a class="header-anchor" href="#避免冗余的-state。" aria-label="Permalink to &quot;避免冗余的 state。&quot;">​</a></h5><p>Avoid redundant state.</p><p>If you can calculate some information from the component’s props or its existing state variables during rendering, you should not put that information into that component’s state. 如果你能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。</p><h5 id="不要在-state-中镜像-备份-props" tabindex="-1">不要在 state 中镜像(备份) props <a class="header-anchor" href="#不要在-state-中镜像-备份-props" aria-label="Permalink to &quot;不要在 state 中镜像(备份) props&quot;">​</a></h5><p>Don’t mirror props in state 只有当你 想要 忽略特定 props 属性的所有更新时，将 props “镜像”到 state 才有意义。 按照惯例，prop 名称以 initial 或 default 开头，以阐明该 prop 的新值将被忽略</p><h5 id="避免重复的-state。" tabindex="-1">避免重复的 state。 <a class="header-anchor" href="#避免重复的-state。" aria-label="Permalink to &quot;避免重复的 state。&quot;">​</a></h5><p>Avoid duplication in state.</p><p>When the same data is duplicated between multiple state variables, or within nested objects, it is difficult to keep them in sync. Reduce duplication when you can. 当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。</p><p>You didn’t need to hold the selected item in state, because only the selected ID is essential. The rest could be calculated during render. 你不需要在 state 中保存 选定的元素，因为只有 选定的 ID 是必要的。 其余的可以在渲染期间计算。</p><h5 id="避免深度嵌套的-state。" tabindex="-1">避免深度嵌套的 state。 <a class="header-anchor" href="#避免深度嵌套的-state。" aria-label="Permalink to &quot;避免深度嵌套的 state。&quot;">​</a></h5><p>Avoid deeply nested state.</p><p>Deeply hierarchical state is not very convenient to update. When possible, prefer to structure state in a flat way. 深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。</p><p>If the state is too nested to update easily, consider making it “flat”. 如果 state 嵌套太深，难以轻松更新，可以考虑将其“扁平化”。</p><p>Now that the state is “flat” (also known as “normalized”), updating nested items becomes easier. 现在 state 已经“扁平化”（也称为“规范化”），更新嵌套项会变得更加容易。</p><p>You can nest state as much as you like, but making it “flat” can solve numerous problems. 你确实可以随心所欲地嵌套 state，但是将其“扁平化”可以解决许多问题。</p><p>It makes state easier to update, and it helps ensure you don’t have duplication in different parts of a nested object. 这使得 state 更容易更新，并且有助于确保在嵌套对象的不同部分中没有重复。</p><p>Sometimes, you can also reduce state nesting by moving some of the nested state into the child components. 有时候，你也可以通过将一些嵌套 state 移动到子组件中来减少 state 的嵌套。</p><p>This works well for ephemeral UI state that doesn’t need to be stored, like whether an item is hovered. 这对于不需要保存的短暂 UI 状态非常有效，比如一个选项是否被悬停。</p><h5 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h5><p>The goal behind these principles is to make state easy to update without introducing mistakes. 这些原则背后的目标是 使 state 易于更新而不引入错误。</p><p>Removing redundant and duplicate data from state helps ensure that all its pieces stay in sync. 从 state 中删除冗余和重复数据有助于确保所有部分保持同步。</p><p>This is similar to how a database engineer might want to “normalize” the database structure to reduce the chance of bugs. 这类似于数据库工程师想要 “规范化”数据库结构，以减少出现错误的机会。</p><p>To paraphrase Albert Einstein, “Make your state as simple as it can be—but no simpler.” 用爱因斯坦的话说，“让你的状态尽可能简单，但不要过于简单。”</p><h3 id="在组件间共享状态" tabindex="-1">在组件间共享状态 <a class="header-anchor" href="#在组件间共享状态" aria-label="Permalink to &quot;在组件间共享状态&quot;">​</a></h3><p>Sometimes, you want the state of two components to always change together. 有时候你希望两个组件的状态始终同步更改。</p><p>To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. 要实现这一点，可以将相关状态从这两个组件上移除，并把这些状态移到最近的父级组件，然后通过 props 将状态传递给这两个组件。</p><p>This is known as “lifting state up”, and it’s one of the most common things you will do writing React code. 这被称为“状态提升”，这是编写 React 代码时常做的事。</p><p>第 1 步: 从子组件中移除状态 第 2 步: 从公共父组件传递硬编码数据 第 3 步: 为公共父组件添加状态</p><p>状态提升通常会改变原状态的数据存储类型。</p><h5 id="可信单一数据源" tabindex="-1">可信单一数据源 <a class="header-anchor" href="#可信单一数据源" aria-label="Permalink to &quot;可信单一数据源&quot;">​</a></h5><p>For each unique piece of state, you will choose the component that “owns” it. 对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state。</p><p>This principle is also known as having a “single source of truth”. 这一原则也被称为拥有 “可信单一数据源”。</p><p>It doesn’t mean that all state lives in one place—but that for each piece of state, there is a specific component that holds that piece of information. 它并不意味着所有状态都存在一个地方——对每个状态来说，都需要一个特定的组件来保存这些状态信息。</p><p>Instead of duplicating shared state between components, lift it up to their common shared parent, and pass it down to the children that need it. 你应该 将状态提升 到公共父级，或 将状态传递 到需要它的子级中，而不是在组件之间复制共享的状态。</p><h3 id="对-state-进行保留和重置" tabindex="-1">对 state 进行保留和重置 <a class="header-anchor" href="#对-state-进行保留和重置" aria-label="Permalink to &quot;对 state 进行保留和重置&quot;">​</a></h3><p>各个组件的 state 是各自独立的。 根据组件在 UI 树中的位置，React 可以跟踪哪些 state 属于哪个组件。 你可以控制在重新渲染过程中何时对 state 进行保留和重置。</p><h4 id="状态与渲染树中的位置相关" tabindex="-1">状态与渲染树中的位置相关 <a class="header-anchor" href="#状态与渲染树中的位置相关" aria-label="Permalink to &quot;状态与渲染树中的位置相关&quot;">​</a></h4><p>React 会为 UI 中的组件结构构建 渲染树。</p><p>当向一个组件添加状态时，那么可能会认为状态“存在”在组件内。</p><p>但实际上，状态是由 React 保存的。 React 通过组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。 只有当在树中相同的位置渲染相同的组件时，React 才会一直保留着组件的 state。</p><h4 id="相同位置的相同组件会使得-state-被保留下来" tabindex="-1">相同位置的相同组件会使得 state 被保留下来 <a class="header-anchor" href="#相同位置的相同组件会使得-state-被保留下来" aria-label="Permalink to &quot;相同位置的相同组件会使得 state 被保留下来&quot;">​</a></h4><p>只要一个组件还被渲染在 UI 树的相同位置，React 就会保留它的 state。 如果它被移除，或者一个不同的组件被渲染在相同的位置，那么 React 就会丢掉它的 state。</p><blockquote><p>记住 对 React 来说重要的是组件在 UI 树中的位置,而不是在 JSX 中的位置！</p></blockquote><h4 id="相同位置的不同组件会使-state-重置" tabindex="-1">相同位置的不同组件会使 state 重置 <a class="header-anchor" href="#相同位置的不同组件会使-state-重置" aria-label="Permalink to &quot;相同位置的不同组件会使 state 重置&quot;">​</a></h4><p>当你在相同位置渲染不同的组件时，组件的整个子树都会被重置。 一般来说，如果你想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”。 结构不同就会导致 state 的销毁，因为 React 会在将一个组件从树中移除时销毁它的 state。</p><h4 id="永远要将组件定义在最上层并且不要把它们的定义嵌套起来" tabindex="-1">永远要将组件定义在最上层并且不要把它们的定义嵌套起来 <a class="header-anchor" href="#永远要将组件定义在最上层并且不要把它们的定义嵌套起来" aria-label="Permalink to &quot;永远要将组件定义在最上层并且不要把它们的定义嵌套起来&quot;">​</a></h4><p>你在相同位置渲染的是 不同 的组件，所以 React 将其下所有的 state 都重置了。 这样会导致 bug 以及性能问题。 为了避免这个问题， 永远要将组件定义在最上层并且不要把它们的定义嵌套起来。</p><h4 id="在相同位置重置-state" tabindex="-1">在相同位置重置 state <a class="header-anchor" href="#在相同位置重置-state" aria-label="Permalink to &quot;在相同位置重置 state&quot;">​</a></h4><p>默认情况下，React 会在一个组件保持在同一位置时保留它的 state。 通常这就是你想要的，所以把它作为默认特性很合理。 但有时候，你可能想要重置一个组件的 state。</p><h5 id="有两个方法可以在它们相互切换时重置-state" tabindex="-1">有两个方法可以在它们相互切换时重置 state： <a class="header-anchor" href="#有两个方法可以在它们相互切换时重置-state" aria-label="Permalink to &quot;有两个方法可以在它们相互切换时重置 state：&quot;">​</a></h5><ul><li>将组件渲染在不同的位置</li><li>使用 key 赋予每个组件一个明确的身份 React 允许你覆盖默认行为，可通过向组件传递一个唯一 key 来 强制 重置其状态。即使渲染的是同一个组件 你可能在 渲染列表 时见到过 key。但 key 不只可以用于列表！你可以使用 key 来让 React 区分任何组件</li></ul><blockquote><p>请记住 key 不是全局唯一的。它们只能指定 父组件内部 的顺序。 使用 key 来重置 state 在处理表单时特别有用。</p></blockquote><h4 id="为被移除的组件保留-state" tabindex="-1">为被移除的组件保留 state <a class="header-anchor" href="#为被移除的组件保留-state" aria-label="Permalink to &quot;为被移除的组件保留 state&quot;">​</a></h4><p>在真正的聊天应用中，你可能会想在用户再次选择前一个收件人时恢复输入 state。 对于一个不可见的组件，有几种方法可以让它的 state “活下去”：</p><p>与其只渲染现在这一个聊天，你可以把 所有 聊天都渲染出来，但用 CSS 把其他聊天隐藏起来。 这些聊天就不会从树中被移除了，所以它们的内部 state 会被保留下来。这种解决方法对于简单 UI 非常有效。 但如果要隐藏的树形结构很大且包含了大量的 DOM 节点，那么性能就会变得很差。</p><p>你可以进行 状态提升 并在父组件中保存每个收件人的草稿消息。 这样即使子组件被移除了也无所谓，因为保留重要信息的是父组件。 这是最常见的解决方法。</p><p>除了 React 的 state，你也可以使用其他数据源。 例如，也许你希望即使用户不小心关闭页面也可以保存一份信息草稿。 要实现这一点，你可以让 Chat 组件通过读取 localStorage 对其 state 进行初始化，并把草稿保存在那里。</p><h3 id="使用-reducer-进行状态管理" tabindex="-1">使用 Reducer 进行状态管理 <a class="header-anchor" href="#使用-reducer-进行状态管理" aria-label="Permalink to &quot;使用 Reducer 进行状态管理&quot;">​</a></h3><p>Reducer 是处理状态的另一种方式。你可以通过三个步骤将 useState 迁移到 useReducer：</p><p>将设置状态的逻辑 修改 成 dispatch 的一个 action； 编写 一个 reducer 函数； 在你的组件中 使用 reducer。</p><p>使用 reducers 管理状态与直接设置状态略有不同。 它不是通过设置状态来告诉 React “要做什么”，而是通过事件处理程序 dispatch 一个 “action” 来指明 “用户刚刚做了什么”。（而状态更新逻辑则保存在其他地方！）</p><p>当像这样分离关注点时，我们可以更容易地理解组件逻辑。 现在，事件处理程序只通过派发 action 来指定 发生了什么，而 reducer 函数通过响应 actions 来决定 状态如何更新。</p><h4 id="对比-usestate-和-usereducer" tabindex="-1">对比 useState 和 useReducer <a class="header-anchor" href="#对比-usestate-和-usereducer" aria-label="Permalink to &quot;对比 useState 和 useReducer&quot;">​</a></h4><p>Reducers 并非没有缺点！以下是比较它们的几种方法：</p><p>代码体积： 通常，在使用 useState 时，一开始只需要编写少量代码。而 useReducer 必须提前编写 reducer 函数和需要调度的 actions。但是，当多个事件处理程序以相似的方式修改 state 时，useReducer 可以减少代码量。</p><p>可读性： 当状态更新逻辑足够简单时，useState 的可读性还行。但是，一旦逻辑变得复杂起来，它们会使组件变得臃肿且难以阅读。在这种情况下，useReducer 允许你将状态更新逻辑与事件处理程序分离开来。</p><p>可调试性： 当使用 useState 出现问题时, 你很难发现具体原因以及为什么。 而使用 useReducer 时， 你可以在 reducer 函数中通过打印日志的方式来观察每个状态的更新，以及为什么要更新（来自哪个 action）。 如果所有 action 都没问题，你就知道问题出在了 reducer 本身的逻辑中。 然而，与使用 useState 相比，你必须单步执行更多的代码。</p><p>可测试性： reducer 是一个不依赖于组件的纯函数。这就意味着你可以单独对它进行测试。 一般来说，我们最好是在真实环境中测试组件，但对于复杂的状态更新逻辑，针对特定的初始状态和 action，断言 reducer 返回的特定状态会很有帮助。</p><p>个人偏好： 并不是所有人都喜欢用 reducer，没关系，这是个人偏好问题。你可以随时在 useState 和 useReducer 之间切换，它们能做的事情是一样的！ 如果你在修改某些组件状态时经常出现问题或者想给组件添加更多逻辑时，我们建议你还是使用 reducer。</p><p>当然，你也不必整个项目都用 reducer，这是可以自由搭配的。你甚至可以在一个组件中同时使用 useState 和 useReducer。</p><h4 id="编写一个好的-reducers" tabindex="-1">编写一个好的 reducers <a class="header-anchor" href="#编写一个好的-reducers" aria-label="Permalink to &quot;编写一个好的 reducers&quot;">​</a></h4><p>编写 reducers 时最好牢记以下两点：</p><p>reducers 必须是纯粹的。 这一点和 状态更新函数 是相似的，reducers 在是在渲染时运行的！ （actions 会排队直到下一次渲染)。 这就意味着 reducers 必须纯净，即当输入相同时，输出也是相同的。 它们不应该包含异步请求、定时器或者任何副作用（对组件外部有影响的操作）。 它们应该以不可变值的方式去更新 对象 和 数组。</p><p>每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化。 举个例子，如果用户在一个由 reducer 管理的表单（包含五个表单项）中点击了 重置按钮，那么 dispatch 一个 reset_form 的 action 比 dispatch 五个单独的 set_field 的 action 更加合理。 如果你在一个 reducer 中打印了所有的 action 日志，那么这个日志应该是很清晰的，它能让你以某种步骤复现已发生的交互或响应。 这对代码调试很有帮助！</p><h3 id="使用-context-进行深层数据传递" tabindex="-1">使用 Context 进行深层数据传递 <a class="header-anchor" href="#使用-context-进行深层数据传递" aria-label="Permalink to &quot;使用 Context 进行深层数据传递&quot;">​</a></h3><p>如果要在组件树中深入传递一些 prop，或者树里的许多组件需要使用相同的 prop，那么传递 prop 可能会变得很麻烦。 Context 允许父组件将一些信息提供给它下层的任何组件，不管该组件多深层也无需通过 props 逐层透传。 传递 props 是将数据通过 UI 树显式传递到使用它的组件的好方法。</p><p>但是当你需要在组件树中深层传递参数以及需要在组件间复用相同的参数时，传递 props 就会变得很麻烦。 最近的根节点父组件可能离需要数据的组件很远，状态提升 到太高的层级会导致 “逐层传递 props” 的情况。</p><p>Context 让父组件可以为它下面的整个组件树提供数据</p><h4 id="step-1-创建-context-并-将其从一个文件中导出" tabindex="-1">Step 1：创建 context,并 将其从一个文件中导出 <a class="header-anchor" href="#step-1-创建-context-并-将其从一个文件中导出" aria-label="Permalink to &quot;Step 1：创建 context,并 将其从一个文件中导出&quot;">​</a></h4><h4 id="step-2-使用-context" tabindex="-1">Step 2：使用 Context <a class="header-anchor" href="#step-2-使用-context" aria-label="Permalink to &quot;Step 2：使用 Context&quot;">​</a></h4><h4 id="step-3-提供-context" tabindex="-1">Step 3：提供 context <a class="header-anchor" href="#step-3-提供-context" aria-label="Permalink to &quot;Step 3：提供 context&quot;">​</a></h4><p>把它们用 context provider 包裹起来 不同的 React context 不会覆盖彼此 Context 让你可以编写“适应周围环境”的组件，并且根据 在哪 （或者说 在哪个 context 中）来渲染它们不同的样子。</p><p>在使用 context 之前，你可以考虑以下几种替代方案：</p><p>从 传递 props 开始。 如果你的组件看起来不起眼，那么通过十几个组件向下传递一堆 props 并不罕见。这有点像是在埋头苦干，但是这样做可以让哪些组件用了哪些数据变得十分清晰！维护你代码的人会很高兴你用 props 让数据流变得更加清晰。</p><p>抽象组件并 将 JSX 作为 children 传递 给它们。 如果你通过很多层不使用该数据的中间组件（并且只会向下传递）来传递数据，这通常意味着你在此过程中忘记了抽象组件。 举个例子，你可能想传递一些像 posts 的数据 props 到不会直接使用这个参数的组件，类似 <code>&lt;Layout posts={posts} /&gt;</code>。 取而代之的是，让 Layout 把 children 当做一个参数，然后渲染 <code>&lt;Layout&gt;&lt;Posts posts={posts} /&gt;&lt;/Layout&gt;</code>。 这样就减少了定义数据的组件和使用数据的组件之间的层级。 如果这两种方法都不适合你，再考虑使用 context。</p><h4 id="context-的使用场景" tabindex="-1">Context 的使用场景 <a class="header-anchor" href="#context-的使用场景" aria-label="Permalink to &quot;Context 的使用场景&quot;">​</a></h4><p>主题： 如果你的应用允许用户更改其外观（例如暗夜模式），你可以在应用顶层放一个 context provider，并在需要调整其外观的组件中使用该 context。</p><p>当前账户： 许多组件可能需要知道当前登录的用户信息。将它放到 context 中可以方便地在树中的任何位置读取它。 某些应用还允许你同时操作多个账户（例如，以不同用户的身份发表评论）。 在这些情况下，将 UI 的一部分包裹到具有不同账户数据的 provider 中会很方便。</p><p>路由： 大多数路由解决方案在其内部使用 context 来保存当前路由。 这就是每个链接“知道”它是否处于活动状态的方式。 如果你创建自己的路由库，你可能也会这么做。</p><p>状态管理： 随着你的应用的增长，最终在靠近应用顶部的位置可能会有很多 state。许多遥远的下层组件可能想要修改它们。 通常 将 reducer 与 context 搭配使用来管理复杂的状态并将其传递给深层的组件来避免过多的麻烦。</p><p>一般而言，如果树中不同部分的远距离组件需要某些信息，context 将会对你大有帮助。</p><h3 id="使用-reducer-和-context-进行状态扩展" tabindex="-1">使用 Reducer 和 Context 进行状态扩展 <a class="header-anchor" href="#使用-reducer-和-context-进行状态扩展" aria-label="Permalink to &quot;使用 Reducer 和 Context 进行状态扩展&quot;">​</a></h3><p>Reducer 帮助你合并组件的状态更新逻辑。 Context 帮助你将信息深入传递给其他组件。 你可以将 reducers 和 context 组合在一起使用，以管理复杂应用的状态。</p><h2 id="受控组件和非受控组件-controlled-and-uncontrolled-components" tabindex="-1">受控组件和非受控组件 Controlled and uncontrolled components <a class="header-anchor" href="#受控组件和非受控组件-controlled-and-uncontrolled-components" aria-label="Permalink to &quot;受控组件和非受控组件 Controlled and uncontrolled components&quot;">​</a></h2><p>考虑该将组件视为“受控”（由 prop 驱动）或是“不受控”（由 state 驱动）是十分有益的。</p><p>It is common to call a component with some local state “uncontrolled”. 通常我们把包含“不受控制”状态的组件称为“非受控组件”</p><p>In contrast, you might say a component is “controlled” when the important information in it is driven by props rather than its own local state. This lets the parent component fully specify its behavior. 相反，当组件中的重要信息是由 props 而不是其自身状态驱动时，就可以认为该组件是“受控组件”。 这就允许父组件完全指定其行为。</p><p>Uncontrolled components are easier to use within their parents because they require less configuration. But they’re less flexible when you want to coordinate them together. 非受控组件通常很简单，因为它们不需要太多配置。但是当你想把它们组合在一起使用时，就不那么灵活了。</p><p>Controlled components are maximally flexible, but they require the parent components to fully configure them with props. 受控组件具有最大的灵活性，但它们需要父组件使用 props 对其进行配置。</p><p>In practice, “controlled” and “uncontrolled” aren’t strict technical terms—each component usually has some mix of both local state and props. 在实践中，“受控”和“非受控”并不是严格的技术术语——通常每个组件都同时拥有内部状态和 props。</p><p>However, this is a useful way to talk about how components are designed and what capabilities they offer. 然而，这对于组件该如何设计和提供什么样功能的讨论是有帮助的。</p><p>When writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state). 当编写一个组件时，你应该考虑哪些信息应该受控制（通过 props），哪些信息不应该受控制（通过 state）。</p><p>But you can always change your mind and refactor later. 当然，你可以随时改变主意并重构代码。</p><h2 id="使用-ref-在不重新渲染的情况下-记住-信息" tabindex="-1">使用 ref 在不重新渲染的情况下“记住”信息 <a class="header-anchor" href="#使用-ref-在不重新渲染的情况下-记住-信息" aria-label="Permalink to &quot;使用 ref 在不重新渲染的情况下“记住”信息&quot;">​</a></h2><p>当你希望组件“记住”某些信息，但又不想让这些信息 触发新的渲染 时，你可以使用 ref</p><p>例如，可以使用 ref 来存储 timeout ID、DOM 元素 和其他不影响组件渲染输出的对象。</p><p>你可以用 ref.current 属性访问该 ref 的当前值。 这个值是有意被设置为可变的，意味着你既可以读取它也可以写入它。</p><p>像 state 一样，你可以让它指向任何东西：字符串、对象，甚至是函数 与 state 不同的是，ref 是一个普通的 JavaScript 对象，具有可以被读取和修改的 current 属性。</p><p>与 state 一样，React 会在每次重新渲染之间保留 ref。 但是，设置 state 会重新渲染组件，更改 ref 不会！</p><p>当一条信息用于渲染时，将它保存在 state 中。 当一条信息仅被事件处理器需要，并且更改它不需要重新渲染时，使用 ref 可能会更高效。</p><p>React state 的限制不适用于 ref。 例如，state 就像 每次渲染的快照，并且 不会同步更新。但是当你改变 ref 的 current 值时，它会立即改变 这是因为 ref 本身是一个普通的 JavaScript 对象， 所以它的行为就像对象那样。</p><p>当你使用 ref 时，也无需担心 避免变更。 只要你改变的对象不用于渲染，React 就不会关心你对 ref 或其内容做了什么。</p><blockquote><p>在渲染期间读取 ref.current 会导致代码不可靠,因为 修改 ref.current 不会导致组件重新渲染。</p></blockquote><h3 id="何时使用-ref" tabindex="-1">何时使用 ref <a class="header-anchor" href="#何时使用-ref" aria-label="Permalink to &quot;何时使用 ref&quot;">​</a></h3><p>通常，当你的组件需要“跳出” React 并与外部 API 通信时，你会用到 ref —— 通常是不会影响组件外观的浏览器 API。</p><p>以下是这些罕见情况中的几个：</p><p>存储 timeout ID 存储和操作 DOM 元素，我们将在 下一页 中介绍 存储不需要被用来计算 JSX 的其他对象。</p><p>如果你的组件需要存储一些值，但不影响渲染逻辑，请选择 ref。</p><h3 id="ref-的最佳实践" tabindex="-1">ref 的最佳实践 <a class="header-anchor" href="#ref-的最佳实践" aria-label="Permalink to &quot;ref 的最佳实践&quot;">​</a></h3><p>遵循这些原则将使你的组件更具可预测性：</p><h4 id="将-ref-视为脱围机制。" tabindex="-1">将 ref 视为脱围机制。 <a class="header-anchor" href="#将-ref-视为脱围机制。" aria-label="Permalink to &quot;将 ref 视为脱围机制。&quot;">​</a></h4><p>当你使用外部系统或浏览器 API 时，ref 很有用。 如果你很大一部分应用程序逻辑和数据流都依赖于 ref，你可能需要重新考虑你的方法。</p><h4 id="不要在渲染过程中读取或写入-ref-current。" tabindex="-1">不要在渲染过程中读取或写入 ref.current。 <a class="header-anchor" href="#不要在渲染过程中读取或写入-ref-current。" aria-label="Permalink to &quot;不要在渲染过程中读取或写入 ref.current。&quot;">​</a></h4><p>如果渲染过程中需要某些信息，请使用 state 代替。 由于 React 不知道 ref.current 何时发生变化，即使在渲染时读取它也会使组件的行为难以预测。 （唯一的例外是像 if (!ref.current) ref.current = new Thing() 这样的代码，它只在第一次渲染期间设置一次 ref。）</p><h2 id="使用-ref-操作-dom" tabindex="-1">使用 ref 操作 DOM <a class="header-anchor" href="#使用-ref-操作-dom" aria-label="Permalink to &quot;使用 ref 操作 DOM&quot;">​</a></h2><p>由于 React 会自动更新 DOM 以匹配渲染输出，因此组件通常不需要操作 DOM。</p><p>但是，有时可能需要访问由 React 管理的 DOM 元素——例如聚焦节点、滚动到此节点，以及测量它的尺寸和位置。</p><p>React 没有内置的方法来执行此类操作，所以需要一个指向 DOM 节点的 ref 来实现。</p><h3 id="如何使用-ref-回调管理-ref-列表" tabindex="-1">如何使用 ref 回调管理 ref 列表 <a class="header-anchor" href="#如何使用-ref-回调管理-ref-列表" aria-label="Permalink to &quot;如何使用 ref 回调管理 ref 列表&quot;">​</a></h3><p>Hook 只能在组件的顶层被调用。不能在循环语句、条件语句或 map() 函数中调用 useRef</p><p>一种可能的解决方案是用一个 ref 引用其父元素，然后用 DOM 操作方法如 querySelectorAll 来寻找它的子节点。 然而，这种方法很脆弱，如果 DOM 结构发生变化，可能会失效或报错。</p><p>另一种解决方案是将函数传递给 ref 属性。 这称为 ref 回调。当需要设置 ref 时，React 将传入 DOM 节点来调用你的 ref 回调，并在需要清除它时传入 null 。 这使你可以维护自己的数组或 Map，并通过其索引或某种类型的 ID 访问任何 ref。</p><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">useRef</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> &#39;react&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;"> default</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> CatFriends</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">	const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> itemsRef</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> useRef</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">	function</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> scrollToId</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">itemId</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">		const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> map</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> getMap</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">		const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> node</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;"> map</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">itemId</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">		node</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">scrollIntoView</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">			behavior</span><span style="--shiki-light:#001080;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> &#39;smooth&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">			block</span><span style="--shiki-light:#001080;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> &#39;nearest&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">			inline</span><span style="--shiki-light:#001080;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> &#39;center&#39;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">		});</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">	function</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> getMap</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">		if</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">itemsRef</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">current</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">			// 首次运行时初始化 Map。</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">			itemsRef</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">current</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> Map</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">		}</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">		return</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;"> itemsRef</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">current</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">		&lt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">			&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">nav</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">				&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> onClick</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> scrollToId</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#098658;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">					Tom</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">				&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">				&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> onClick</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> scrollToId</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#098658;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">					Maru</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">				&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">				&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> onClick</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> scrollToId</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#098658;--shiki-dark:#D19A66;">9</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">					Jellylorum</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">				&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">button</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">			&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">nav</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">			&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">				&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">ul</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">					{</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">catList</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">map</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">cat</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;"> =&gt;</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">						&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">li</span></span>
<span class="line"><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">							key</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">cat</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">id</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">							ref</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">node</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">								const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> map</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;"> getMap</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">								if</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">node</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">									map</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">cat</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">id</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">node</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">								} </span><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">									map</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">delete</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">cat</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">id</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">								}</span></span>
<span class="line"><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">							}</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">						&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">							&lt;</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">img</span></span>
<span class="line"><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">								src</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">cat</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">imageUrl</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#E50000;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">								alt</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">{</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;">\`Cat #</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">\${</span><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">cat</span><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">id</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;">\`</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">							/&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">						&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">li</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000FF;--shiki-dark:#ABB2BF;">					))</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">				&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">ul</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">			&lt;/</span><span style="--shiki-light:#800000;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#800000;--shiki-dark:#ABB2BF;">		&lt;/&gt;</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">	);</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#0070C1;--shiki-dark:#E5C07B;"> catList</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> [];</span></span>
<span class="line"><span style="--shiki-light:#AF00DB;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#098658;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#098658;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#000000;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E5C07B;">	catList</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">push</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">({</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">		id</span><span style="--shiki-light:#001080;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">		imageUrl</span><span style="--shiki-light:#001080;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> \`https://placekitten.com/250/200?image=</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">\${</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#0000FF;--shiki-dark:#C678DD;">}</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;">\`</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">	});</span></span>
<span class="line"><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br></div></div><p>在这个例子中，itemsRef 保存的不是单个 DOM 节点，而是保存了包含列表项 ID 和 DOM 节点的 Map。 (Ref 可以保存任何值！) 每个列表项上的 ref 回调负责更新 Map 这使你可以之后从 Map 读取单个 DOM 节点。</p><h3 id="使用-ref-转发管理-dom-节点-forwardref" tabindex="-1">使用 ref 转发管理 DOM 节点 forwardRef <a class="header-anchor" href="#使用-ref-转发管理-dom-节点-forwardref" aria-label="Permalink to &quot;使用 ref 转发管理 DOM 节点 forwardRef&quot;">​</a></h3><p>默认情况下，React 不允许组件访问其他组件的 DOM 节点。甚至自己的子组件也不行！这是故意的。 Refs 是一种脱围机制，应该谨慎使用。 手动操作 另一个 组件的 DOM 节点会使你的代码更加脆弱。</p><p>相反，想要 暴露其 DOM 节点的组件必须选择该行为。一个组件可以指定将它的 ref “转发”给一个子组件</p><p>在设计系统中，将低级组件（如按钮、输入框等）的 ref 转发到它们的 DOM 节点是一种常见模式。</p><p>另一方面，像表单、列表或页面段落这样的高级组件通常不会暴露它们的 DOM 节点，以避免对 DOM 结构的意外依赖。</p><h3 id="使用命令句柄暴露一部分-api" tabindex="-1">使用命令句柄暴露一部分 API <a class="header-anchor" href="#使用命令句柄暴露一部分-api" aria-label="Permalink to &quot;使用命令句柄暴露一部分 API&quot;">​</a></h3><p>useImperativeHandle 指示 React 将你自己指定的对象作为父组件的 ref 值 在这种情况下，ref “句柄”不是 DOM 节点，而是你在 useImperativeHandle 调用中创建的自定义对象。</p><h3 id="react-何时添加-refs" tabindex="-1">React 何时添加 refs <a class="header-anchor" href="#react-何时添加-refs" aria-label="Permalink to &quot;React 何时添加 refs&quot;">​</a></h3><p>在 React 中，每次更新都分为 两个阶段：</p><p>在 渲染 阶段， React 调用你的组件来确定屏幕上应该显示什么。 在 提交 阶段， React 把变更应用于 DOM。</p><h4 id="通常-你-不希望-在渲染期间访问-refs。" tabindex="-1">通常，你 不希望 在渲染期间访问 refs。 <a class="header-anchor" href="#通常-你-不希望-在渲染期间访问-refs。" aria-label="Permalink to &quot;通常，你 不希望 在渲染期间访问 refs。&quot;">​</a></h4><p>这也适用于保存 DOM 节点的 refs。 在第一次渲染期间，DOM 节点尚未创建，因此 ref.current 将为 null。 在渲染更新的过程中，DOM 节点还没有更新。 所以读取它们还为时过早。</p><h4 id="react-在提交阶段设置-ref-current。" tabindex="-1">React 在提交阶段设置 ref.current。 <a class="header-anchor" href="#react-在提交阶段设置-ref-current。" aria-label="Permalink to &quot;React 在提交阶段设置 ref.current。&quot;">​</a></h4><p>在更新 DOM 之前，React 将受影响的 ref.current 值设置为 null。 更新 DOM 后，React 立即将它们设置到相应的 DOM 节点。</p><h4 id="通常-你将从事件处理器访问-refs。" tabindex="-1">通常，你将从事件处理器访问 refs。 <a class="header-anchor" href="#通常-你将从事件处理器访问-refs。" aria-label="Permalink to &quot;通常，你将从事件处理器访问 refs。&quot;">​</a></h4><p>如果你想使用 ref 执行某些操作，但没有特定的事件可以执行此操作，你可能需要一个 effect。</p><h4 id="用-flushsync-同步更新-state" tabindex="-1">用 flushSync 同步更新 state <a class="header-anchor" href="#用-flushsync-同步更新-state" aria-label="Permalink to &quot;用 flushSync 同步更新 state&quot;">​</a></h4><p>在 React 中，state 更新是排队进行的。通常，这就是你想要的。 要解决此问题，你可以强制 React 同步更新（“刷新”）DOM。 为此，从 react-dom 导入 flushSync 并将 state 更新包裹 到 flushSync 调用中</p><p>请注意，为了强制 React 在滚动前更新 DOM，flushSync 调用是必需的</p><h3 id="使用-refs-操作-dom-的最佳实践" tabindex="-1">使用 refs 操作 DOM 的最佳实践 <a class="header-anchor" href="#使用-refs-操作-dom-的最佳实践" aria-label="Permalink to &quot;使用 refs 操作 DOM 的最佳实践&quot;">​</a></h3><p>Refs 是一种脱围机制。你应该只在你必须“跳出 React”时使用它们。 这方面的常见示例包括管理焦点、滚动位置或调用 React 未暴露的浏览器 API。</p><p>如果你坚持聚焦和滚动等非破坏性操作，应该不会遇到任何问题。 但是，如果你尝试手动修改 DOM，则可能会与 React 所做的更改发生冲突。</p><p>避免更改由 React 管理的 DOM 节点 但是，这并不意味着你完全不能这样做。它需要谨慎。 你可以安全地修改 React 没有理由更新的部分 DOM</p><h2 id="使用-effect-实现与-react-之外的系统同步" tabindex="-1">使用 Effect 实现与 React 之外的系统同步 <a class="header-anchor" href="#使用-effect-实现与-react-之外的系统同步" aria-label="Permalink to &quot;使用 Effect 实现与 React 之外的系统同步&quot;">​</a></h2><p>有些组件需要与外部系统同步。</p><p>例如，可能需要根据 React 状态控制非 React 组件、设置服务器连接或在组件出现在屏幕上时发送分析日志。</p><p>与处理特定事件的事件处理程序不同，Effect 在渲染后运行一些代码。</p><p>使用它将组件与 React 之外的系统同步。</p><p>许多 Effect 也会自行“清理”。 例如，与聊天服务器建立连接的 Effect 应该返回一个 cleanup 函数，告诉 React 如何断开组件与该服务器的连接</p><h2 id="你可能不需要-effect" tabindex="-1">你可能不需要 Effect <a class="header-anchor" href="#你可能不需要-effect" aria-label="Permalink to &quot;你可能不需要 Effect&quot;">​</a></h2><p>Effect 是 React 范式中的一种脱围机制。</p><p>它们可以“逃出” React 并使组件和一些外部系统同步。</p><p>如果没有涉及到外部系统（例如，需要根据一些 props 或 state 的变化来更新一个组件的 state），不应该使用 Effect。</p><p>移除不必要的 Effect 可以让代码更容易理解，运行得更快，并且更少出错。</p><h3 id="有两种常见的不必使用-effect-的情况" tabindex="-1">有两种常见的不必使用 Effect 的情况： <a class="header-anchor" href="#有两种常见的不必使用-effect-的情况" aria-label="Permalink to &quot;有两种常见的不必使用 Effect 的情况：&quot;">​</a></h3><ul><li><p>不必为了渲染而使用 Effect 来转换数据。 相反，在渲染时进行尽可能多地计算</p></li><li><p>不必使用 Effect 来处理用户事件。</p></li></ul><h2 id="响应式-effect-的生命周期" tabindex="-1">响应式 Effect 的生命周期 <a class="header-anchor" href="#响应式-effect-的生命周期" aria-label="Permalink to &quot;响应式 Effect 的生命周期&quot;">​</a></h2><p>Effect 的生命周期不同于组件。</p><p>组件可以挂载、更新或卸载。 Effect 只能做两件事：开始同步某些东西，然后停止同步它。</p><p>如果 Effect 依赖于随时间变化的 props 和 state，这个循环可能会发生多次。</p><h2 id="从-effect-中分离事件" tabindex="-1">从 Effect 中分离事件 <a class="header-anchor" href="#从-effect-中分离事件" aria-label="Permalink to &quot;从 Effect 中分离事件&quot;">​</a></h2><p>事件处理程序仅在再次执行相同的交互时重新运行。</p><p>与事件处理程序不同，如果 Effect 读取的任何值（如 props 或 state）与上次渲染期间不同，则会重新同步。</p><p>有时，需要混合两种行为：Effect 重新运行以响应某些值而不是其他值。</p><p>Effect 中的所有代码都是 响应式的。如果它读取的某些响应式的值由于重新渲染而发生变化，它将再次运行。</p><h2 id="移除-effect-依赖" tabindex="-1">移除 Effect 依赖 <a class="header-anchor" href="#移除-effect-依赖" aria-label="Permalink to &quot;移除 Effect 依赖&quot;">​</a></h2><p>当你写 Effect 时，代码检查器会验证是否已经将 Effect 读取的每一个响应式值（如 props 和 state）包含在 Effect 的依赖列表中。</p><p>这可以确保 Effect 与组件的 props 和 state 保持同步。</p><p>不必要的依赖关系可能会导致 Effect 运行过于频繁，甚至产生无限循环。</p><p>删除它们的方式取决于具体情况。</p><h2 id="使用自定义-hook-复用逻辑" tabindex="-1">使用自定义 Hook 复用逻辑 <a class="header-anchor" href="#使用自定义-hook-复用逻辑" aria-label="Permalink to &quot;使用自定义 Hook 复用逻辑&quot;">​</a></h2><p>你可以创建自定义 Hooks，将它们组合在一起，在它们之间传递数据，并在组件之间重用它们。</p><p>随着应用不断变大，你将减少手动编写的 Effect，因为你将能够重用已经编写的自定义 Hooks。</p><h2 id="什么是-effect-它与事件-event-有何不同" tabindex="-1">什么是 Effect，它与事件（event）有何不同？ <a class="header-anchor" href="#什么是-effect-它与事件-event-有何不同" aria-label="Permalink to &quot;什么是 Effect，它与事件（event）有何不同？&quot;">​</a></h2><p>在谈到 Effect 之前，你需要熟悉 React 组件中的两种逻辑类型：</p><p>Rendering code (introduced in Describing the UI) lives at the top level of your component. 渲染逻辑代码（在 描述 UI 中有介绍）位于组件的顶层。</p><p>This is where you take the props and state, transform them, and return the JSX you want to see on the screen. 你将在这里接收 props 和 state，并对它们进行转换，最终返回你想在屏幕上看到的 JSX。</p><p>Rendering code must be pure. Like a math formula, it should only calculate the result, but not do anything else. 渲染的代码必须是纯粹的——就像数学公式一样，它只应该“计算”结果，而不做其他任何事情。</p><p>Event handlers (introduced in Adding Interactivity) are nested functions inside your components that do things rather than just calculate them. 事件处理程序（在 添加交互性 中介绍）是嵌套在组件内部的函数，而不仅仅是计算函数。</p><p>An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. 事件处理程序可能会更新输入字段、提交 HTTP POST 请求以购买产品，或者将用户导航到另一个屏幕。</p><p>Event handlers contain “side effects” (they change the program’s state) caused by a specific user action (for example, a button click or typing). 事件处理程序包含由特定用户操作（例如按钮点击或键入）引起的“副作用”（它们改变了程序的状态）</p><p>Effects let you specify side effects that are caused by rendering itself, rather than by a particular event. Effect 允许你指定由渲染本身，而不是特定事件引起的副作用</p><p>Effects run at the end of a commit after the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library). Effect 在屏幕更新后的 提交阶段 运行。 这是一个很好的时机，可以将 React 组件与某个外部系统（如网络或第三方库）同步。</p><blockquote><p>Effect 在 React 中是专有定义——由渲染引起的副作用。 为了指代更广泛的编程概念，也可以将其称为“副作用（side effect）”。 与事件不同，Effect 是由渲染本身，而非特定交互引起的</p></blockquote><p>在渲染期间调用 ref.current.focus() 本身是不正确的。因为这会产生“副作用”。 副作用要么应该放在事件处理程序里面，要么在 useEffect 中。 在这种情况下，副作用是组件渲染引起的，而不是任何特定的交互引起的，因此应该将它放在 Effect 中。</p><h2 id="你可能不需要-effect-1" tabindex="-1">你可能不需要 Effect <a class="header-anchor" href="#你可能不需要-effect-1" aria-label="Permalink to &quot;你可能不需要 Effect&quot;">​</a></h2><p>Don’t rush to add Effects to your components. 不要随意在你的组件中使用 Effect。</p><p>Keep in mind that Effects are typically used to “step out” of your React code and synchronize with some external system. 记住，Effect 通常用于暂时“跳出” React 代码并与一些 外部 系统进行同步。</p><p>This includes browser APIs, third-party widgets, network, and so on. 这包括浏览器 API、第三方小部件，以及网络等等。</p><p>If your Effect only adjusts some state based on other state, you might not need an Effect. 如果你想用 Effect 仅根据其他状态调整某些状态，那么 你可能不需要 Effect。</p><p>Effect 是 React 范式中的一种脱围机制。 它们让你可以 “逃出” React 并使组件和一些外部系统同步，比如非 React 组件、网络和浏览器 DOM。 如果没有涉及到外部系统（例如，你想根据 props 或 state 的变化来更新一个组件的 state），你就不应该使用 Effect。</p><p>移除不必要的 Effect 可以让你的代码更容易理解，运行得更快，并且更少出错。</p><h3 id="如何移除不必要的-effect" tabindex="-1">如何移除不必要的 Effect <a class="header-anchor" href="#如何移除不必要的-effect" aria-label="Permalink to &quot;如何移除不必要的 Effect&quot;">​</a></h3><p>有两种不必使用 Effect 的常见情况：</p><h4 id="你不必使用-effect-来转换渲染所需的数据。" tabindex="-1">你不必使用 Effect 来转换渲染所需的数据。 <a class="header-anchor" href="#你不必使用-effect-来转换渲染所需的数据。" aria-label="Permalink to &quot;你不必使用 Effect 来转换渲染所需的数据。&quot;">​</a></h4><p>例如，你想在展示一个列表前先做筛选。 你的直觉可能是写一个当列表变化时更新 state 变量的 Effect。然而，这是低效的。 当你更新这个 state 时，React 首先会调用你的组件函数来计算应该显示在屏幕上的内容。 然后 React 会把这些变化“提交”到 DOM 中来更新屏幕。 然后 React 会执行你的 Effect。 如果你的 Effect 也立即更新了这个 state，就会重新执行整个流程。 为了避免不必要的渲染流程，应在你的组件顶层转换数据。 这些代码会在你的 props 或 state 变化时自动重新执行。</p><h4 id="你不必使用-effect-来处理用户事件。" tabindex="-1">你不必使用 Effect 来处理用户事件。 <a class="header-anchor" href="#你不必使用-effect-来处理用户事件。" aria-label="Permalink to &quot;你不必使用 Effect 来处理用户事件。&quot;">​</a></h4><p>例如，你想在用户购买一个产品时发送一个 <code>/api/buy</code> 的 POST 请求并展示一个提示。 在这个购买按钮的点击事件处理函数中，你确切地知道会发生什么。 但是当一个 Effect 运行时，你却不知道用户做了什么（例如，点击了哪个按钮）。 这就是为什么你通常应该在相应的事件处理函数中处理用户事件。</p><h3 id="根据-props-或-state-来更新-state" tabindex="-1">根据 props 或 state 来更新 state <a class="header-anchor" href="#根据-props-或-state-来更新-state" aria-label="Permalink to &quot;根据 props 或 state 来更新 state&quot;">​</a></h3><p>如果一个值可以基于现有的 props 或 state 计算得出，不要把它作为一个 state，而是在渲染期间直接计算这个值。</p><p>这将使你的代码更快（避免了多余的 “级联” 更新）、更简洁（移除了一些代码）以及更少出错（避免了一些因为不同的 state 变量之间没有正确同步而导致的问题）</p><p>如果你可以在渲染期间计算某些内容，则不需要使用 Effect</p><h3 id="缓存昂贵的计算" tabindex="-1">缓存昂贵的计算 <a class="header-anchor" href="#缓存昂贵的计算" aria-label="Permalink to &quot;缓存昂贵的计算&quot;">​</a></h3><p>你可以使用 useMemo Hook 缓存（或者说 记忆（memoize））一个昂贵的计算。</p><p>你传入 useMemo 的函数会在渲染期间执行，所以它仅适用于 纯函数 场景。</p><p>想要缓存昂贵的计算，请使用 useMemo 而不是 useEffect</p><h4 id="如何判断计算是昂贵的" tabindex="-1">如何判断计算是昂贵的？ <a class="header-anchor" href="#如何判断计算是昂贵的" aria-label="Permalink to &quot;如何判断计算是昂贵的？&quot;">​</a></h4><p>一般来说只有你创建或循环遍历了成千上万个对象时才会很耗费时间。</p><p>如果总耗时达到了一定量级（比方说 1ms 或更多），那么把计算结果记忆（memoize）起来可能是有意义的。</p><p>useMemo 不会让 第一次 渲染变快。它只是帮助你跳过不必要的更新。</p><h3 id="当-props-变化时重置所有-state" tabindex="-1">当 props 变化时重置所有 state <a class="header-anchor" href="#当-props-变化时重置所有-state" aria-label="Permalink to &quot;当 props 变化时重置所有 state&quot;">​</a></h3><p>通常，当在相同的位置渲染相同的组件时，React 会保留状态</p><p>将你的组件拆分为两个组件，并从外部的组件传递一个 key 属性给内部的组件</p><p>想要重置整个组件树的 state，请传入不同的 key</p><h3 id="当-prop-变化时调整部分-state" tabindex="-1">当 prop 变化时调整部分 state <a class="header-anchor" href="#当-prop-变化时调整部分-state" aria-label="Permalink to &quot;当 prop 变化时调整部分 state&quot;">​</a></h3><p>有时候，当 prop 变化时，你可能只想重置或调整部分 state ，而不是所有 state。</p><p>像这样 存储前序渲染的信息 可能很难理解，但它比在 Effect 中更新这个 state 要好</p><p>在渲染期间更新组件时，React 会丢弃已经返回的 JSX 并立即尝试重新渲染。</p><p>为了避免非常缓慢的级联重试，React 只允许在渲染期间更新 同一 组件的状态。 如果你在渲染期间更新另一个组件的状态，你会看到一条报错信息。</p><p>你可以像这样调整 state，但任何其他副作用（比如变化 DOM 或设置的延时）应该留在事件处理函数或 Effect 中，以 保持组件纯粹。</p><p>虽然这种方式比 Effect 更高效，但大多数组件也不需要它。 无论你怎么做，根据 props 或其他 state 来调整 state 都会使数据流更难理解和调试。 <strong>总是检查是否可以通过添加 key 来重置所有 state，或者 在渲染期间计算所需内容。</strong></p><h3 id="在事件处理函数中共享逻辑" tabindex="-1">在事件处理函数中共享逻辑 <a class="header-anchor" href="#在事件处理函数中共享逻辑" aria-label="Permalink to &quot;在事件处理函数中共享逻辑&quot;">​</a></h3><p>避免：在 Effect 中处理属于事件特定的逻辑 当你不确定某些代码应该放在 Effect 中还是事件处理函数中时，先自问 为什么 要执行这些代码。 Effect 只用来执行那些页面显示出来给用户时，组件 需要执行 的代码</p><h3 id="发送-post-请求" tabindex="-1">发送 POST 请求 <a class="header-anchor" href="#发送-post-请求" aria-label="Permalink to &quot;发送 POST 请求&quot;">​</a></h3><p>当你决定将某些逻辑放入事件处理函数还是 Effect 中时，你需要回答的主要问题是：从用户的角度来看它是 怎样的逻辑。</p><p>如果这个逻辑是由某个特定的交互引起的，请将它保留在相应的事件处理函数中。</p><p>如果是由用户在屏幕上 看到 组件时引起的，请将它保留在 Effect 中。</p><h3 id="链式计算" tabindex="-1">链式计算 <a class="header-anchor" href="#链式计算" aria-label="Permalink to &quot;链式计算&quot;">​</a></h3><p>避免：链接多个 Effect 仅仅为了相互触发调整 state</p><p>尽可能在渲染期间进行计算，以及在事件处理函数中调整 state</p><p>在某些情况下，你 无法 在事件处理函数中直接计算出下一个 state。</p><p>例如，试想一个具有多个下拉菜单的表单，如果下一个下拉菜单的选项取决于前一个下拉菜单选择的值。</p><p>这时，Effect 链是合适的，因为你需要与网络进行同步</p><p>如果你需要更新多个组件的 state，最好在单个事件处理函数中处理。</p><h3 id="初始化应用" tabindex="-1">初始化应用 <a class="header-anchor" href="#初始化应用" aria-label="Permalink to &quot;初始化应用&quot;">​</a></h3><p>有些逻辑只需要在应用加载时执行一次。</p><p>如果某些逻辑必须在 每次应用加载时执行一次，而不是在 每次组件挂载时执行一次，可以添加一个顶层变量来记录它是否已经执行过了</p><p>顶层代码会在组件被导入时执行一次——即使它最终并没有被渲染。 为了避免在导入任意组件时降低性能或产生意外行为，请不要过度使用这种方法。 将应用级别的初始化逻辑保留在像 App.js 这样的根组件模块或你的应用入口中。</p><p>组件 显示 时就需要执行的代码应该放在 Effect 中，否则应该放在事件处理函数中</p><h3 id="通知父组件有关-state-变化的信息" tabindex="-1">通知父组件有关 state 变化的信息 <a class="header-anchor" href="#通知父组件有关-state-变化的信息" aria-label="Permalink to &quot;通知父组件有关 state 变化的信息&quot;">​</a></h3><p>避免：onChange 处理函数执行的时间太晚了 React 会 批量 处理来自不同组件的更新，所以只会有一个渲染流程。</p><p>“状态提升” 允许父组件通过切换自身的 state 来完全控制 Toggle 组件。 这意味着父组件会包含更多的逻辑，但整体上需要关心的状态变少了。 每当你尝试保持两个不同的 state 变量之间的同步时，试试状态提升！</p><p>当你尝试在不同组件中同步 state 变量时，请考虑状态提升。</p><h3 id="将数据传递给父组件" tabindex="-1">将数据传递给父组件 <a class="header-anchor" href="#将数据传递给父组件" aria-label="Permalink to &quot;将数据传递给父组件&quot;">​</a></h3><p>避免：在 Effect 中传递数据给父组件</p><p>在 React 中，数据从父组件流向子组件。 当你在屏幕上看到了一些错误时，你可以通过一路追踪组件树来寻找错误信息是从哪个组件传递下来的，从而找到传递了错误的 prop 或具有错误的 state 的组件。</p><p>当子组件在 Effect 中更新其父组件的 state 时，数据流变得非常难以追踪。 既然子组件和父组件都需要相同的数据，那么可以让父组件获取那些数据，并将其 向下传递 给子组件</p><h3 id="订阅外部-store" tabindex="-1">订阅外部 store <a class="header-anchor" href="#订阅外部-store" aria-label="Permalink to &quot;订阅外部 store&quot;">​</a></h3><p>有时候，你的组件可能需要订阅 React state 之外的一些数据。 这些数据可能来自第三方库或内置浏览器 API。 由于这些数据可能在 React 无法感知的情况下发变化，你需要在你的组件中手动订阅它们。 这经常使用 Effect 来实现</p><p>尽管通常可以使用 Effect 来实现此功能，但 React 为此针对性地提供了一个 Hook 用于订阅外部 store。 删除 Effect 并将其替换为调用 <strong>useSyncExternalStore</strong></p><h3 id="获取数据" tabindex="-1">获取数据 <a class="header-anchor" href="#获取数据" aria-label="Permalink to &quot;获取数据&quot;">​</a></h3><p>你可以使用 Effect 获取数据，但你需要实现清除逻辑以避免竞态条件</p><p>“竞态条件”：两个不同的请求 “相互竞争”，并以与你预期不符的顺序返回</p><p>为了修复这个问题，你需要添加一个 清理函数 来忽略较早的返回结果</p><p>虽然仅仅使用自定义 Hook 不如使用框架内置的数据获取机制高效，但将数据获取逻辑移动到自定义 Hook 中将使后续采用高效的数据获取策略更加容易。</p><p>一般来说，当你不得不编写 Effect 时，请留意是否可以将某段功能提取到专门的内置 API 或一个更具声明性的自定义 Hook 中 你会发现组件中的原始 useEffect 调用越少，维护应用将变得更加容易。</p><h2 id="如何编写-effect" tabindex="-1">如何编写 Effect <a class="header-anchor" href="#如何编写-effect" aria-label="Permalink to &quot;如何编写 Effect&quot;">​</a></h2><p>编写 Effect 需要遵循以下三个规则：</p><h3 id="声明-effect。" tabindex="-1">声明 Effect。 <a class="header-anchor" href="#声明-effect。" aria-label="Permalink to &quot;声明 Effect。&quot;">​</a></h3><p>默认情况下，Effect 会在每次渲染后都会执行。</p><p>每当你的组件渲染时，React 将更新屏幕，然后运行 useEffect 中的代码。 换句话说，useEffect 会把这段代码放到屏幕更新渲染之后执行。</p><p>在 React 中，JSX 的渲染必须是纯粹操作，不应该包含任何像修改 DOM 的副作用。</p><p>把调用 DOM 方法的操作封装在 Effect 中，你可以让 React 先更新屏幕，确定相关 DOM 创建好了以后然后再运行 Effect。</p><p>Effect 通常应该使组件与 外部 系统保持同步。 如果没有外部系统，你只想根据其他状态调整一些状态，那么 你也许不需要 Effect</p><h3 id="指定-effect-依赖。" tabindex="-1">指定 Effect 依赖。 <a class="header-anchor" href="#指定-effect-依赖。" aria-label="Permalink to &quot;指定 Effect 依赖。&quot;">​</a></h3><p>大多数 Effect 应该按需执行，而不是在每次渲染后都执行。 例如，淡入动画应该只在组件出现时触发。连接和断开服务器的操作只应在组件出现和消失时，或者切换聊天室时执行。</p><p>依赖数组可以包含多个依赖项。 当指定的所有依赖项在上一次渲染期间的值与当前值完全相同时，React 会跳过重新运行该 Effect。 React 使用 Object.is 比较依赖项的值</p><p>请注意，不能随意选择依赖项。 如果你指定的依赖项不能与 Effect 代码所期望的相匹配时，lint 将会报错，这将帮助你找到代码中的问题。 如果你不希望某些代码重新运行，那么你应当 重新编辑 Effect 代码本身，使其不需要该依赖项。</p><h4 id="为什么依赖数组中可以省略-ref" tabindex="-1">为什么依赖数组中可以省略 ref? <a class="header-anchor" href="#为什么依赖数组中可以省略-ref" aria-label="Permalink to &quot;为什么依赖数组中可以省略 ref?&quot;">​</a></h4><p>这是因为 ref 具有 稳定 的标识：React 保证 每轮渲染中调用 useRef 所产生的引用对象时，获取到的对象引用总是相同的， 即获取到的对象引用永远不会改变，所以它不会导致重新运行 Effect。 因此，依赖数组中是否包含它并不重要。当然也可以包括它</p><p>例如，如果 ref 是从父组件传递的，则必须在依赖项数组中指定它。 这样做是合适的，因为无法确定父组件是否始终是传递相同的 ref，或者可能是有条件地传递几个 ref 之一。 因此，你的 Effect 将取决于传递的是哪个 ref。</p><p>useState 返回的 set 函数 也有稳定的标识符，所以也可以把它从依赖数组中忽略掉。 如果在忽略某个依赖项时 linter 不会报错，那么这么做就是安全的。</p><h3 id="必要时添加清理-cleanup-函数。" tabindex="-1">必要时添加清理（cleanup）函数。 <a class="header-anchor" href="#必要时添加清理-cleanup-函数。" aria-label="Permalink to &quot;必要时添加清理（cleanup）函数。&quot;">​</a></h3><p>有时 Effect 需要指定如何停止、撤销，或者清除它的效果。 例如，“连接”操作需要“断连”，“订阅”需要“退订”，“获取”既需要“取消”也需要“忽略”。</p><p>如果 Effect 订阅了某些事件，清理函数应该退订这些事件</p><p>如果 Effect 对某些内容加入了动画，清理函数应将动画重置</p><p>如果 Effect 将会获取数据，清理函数应该要么 中止该数据获取操作，要么忽略其结果</p><p>React 总是在执行下一轮渲染的 Effect 之前清理上一轮渲染的 Effect</p><p>每一轮渲染都有自己的 Effect,Effect 也是渲染输出的一部分</p><p>如果 Effect 因为重新挂载而中断，那么需要实现一个清理函数。</p><p>React 将在下次 Effect 运行之前以及卸载期间这两个时候调用清理函数。</p><p>其实，每个 Effect 都可以在里面设置一个 ignore 标记变量。 在最开始，ignore 被设置为 false。 然而，当 Effect 执行清理函数后，ignore 就会被设置为 true。 所以此时请求完成的顺序并不重要</p><h4 id="不要在-effect-中执行购买商品一类的操作" tabindex="-1">不要在 Effect 中执行购买商品一类的操作 <a class="header-anchor" href="#不要在-effect-中执行购买商品一类的操作" aria-label="Permalink to &quot;不要在 Effect 中执行购买商品一类的操作&quot;">​</a></h4><p>“购买”的操作不应由组件的挂载、渲染引起的； 它是由特定的交互作用引起的，它应该只在用户按下按钮时运行。</p><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;Contributors&quot;">​</a></h2>`,621);function g(t,y,b,B,q,F){const s=r,i=p,n=o;return k(),h("div",null,[f,c("p",null,"当你下次在 JSX 中看到 "+d(t.和)+" 时，就知道它只不过是包在大括号里的一个对象罢了！",1),m,e(s,{readTime:"91",words:"25.9k"}),e(i),e(n)])}const w=l(u,[["render",g]]);export{E as __pageData,w as default};
