import{_ as i,a as p,b as t}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.BCVHfIj7.js";import{_ as l,c as r,I as s,a7 as o,o as h}from"./chunks/framework.DGCt2JJv.js";import"./chunks/dayjs.min.DZyl58SH.js";const d="/long-press/assets/6d545515.DvnCFeM4.png",P=JSON.parse('{"title":"Windows Powershell 的改进","description":"","frontmatter":{},"headers":[],"relativePath":"tools/Windows终端优化.md","filePath":"tools/Windows终端优化.md","lastUpdated":1713718044000}'),c={name:"tools/Windows终端优化.md"},u=o(`<h1 id="windows-powershell-的改进" tabindex="-1">Windows Powershell 的改进 <a class="header-anchor" href="#windows-powershell-的改进" aria-label="Permalink to &quot;Windows Powershell 的改进&quot;">​</a></h1><p>原来的Windows Powershell使用oh-my-posh进行了Prompt美化，直接在官网使用了默认方案，但启动速度一直不是很理想。</p><p>后面才知道oh-my-posh 3用Golang重写了，原因是想用到不同终端上（疯了，别的终端为什么要用powershell的东西），才变得又卡又慢，体积还增大了。</p><p>根据上面的速度测试结果，我打算在两个Powershell上都换用starship作为Prompt工具，Windows Powershell就不做过多配置。</p><p>首先卸载现在的oh-my-posh，先用(Get-Command oh-my-posh).Source 得到exe的目录，然后找到卸载程序，直接运行即可。</p><h2 id="根据官网提示安装starship" tabindex="-1">根据官网提示安装starship： <a class="header-anchor" href="#根据官网提示安装starship" aria-label="Permalink to &quot;根据官网提示安装starship：&quot;">​</a></h2><p><a href="https://starship.rs/zh-cn/guide/" target="_blank" rel="noreferrer">https://starship.rs/zh-cn/guide/</a></p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">scoop</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> starship</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><a href="https://github.com/starship/starship/releases/tag/v1.18.1" target="_blank" rel="noreferrer">https://github.com/starship/starship/releases/tag/v1.18.1</a></p><p>也可以通过shell脚本快速安装。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">curl</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;"> -sS</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> https://starship.rs/install.sh</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> | </span><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">sh</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或者使用Rust的包管理器cargo安装，前提是已经安装了Rust。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">cargo</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> starship</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;"> --locked</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="启用" tabindex="-1">启用 <a class="header-anchor" href="#启用" aria-label="Permalink to &quot;启用&quot;">​</a></h2><p>要使 Starship 在终端中产生效果，需要在各个终端的配置文件中启用。例如对于 Bash，需要执行：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#56B6C2;">echo</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> &#39;eval &quot;$(starship init bash)&quot;&#39;</span><span style="--shiki-light:#000000;--shiki-dark:#ABB2BF;"> &gt;&gt; </span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;">~/.profile</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>对于 Powershell，可以使用 VS Code 直接编辑$PROFILE：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">code</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> $PROFILE</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>并在打开的文件最后，加入一行：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>Invoke-Expression (&amp;starship init powershell)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="powershell-7的改进" tabindex="-1">Powershell 7的改进 <a class="header-anchor" href="#powershell-7的改进" aria-label="Permalink to &quot;Powershell 7的改进&quot;">​</a></h2><p>除了在Windows Powershell中的Prompt工具外，Powershell 7 作为开发终端，我还需求一些额外的zsh功能：</p><p>Bash-like Tab 补全 自动命令建议（IntelliSense） 基于历史记录的搜索 经过调研发现，上述这些功能都在Powershell官方提供的PSReadLine包中提供了，更巧的是这个包在Windows Powershell 5.1 和Powershell 7中都已经内置了，只需要使用选项激活即可。</p><p>事不宜迟，立刻编辑$PROFILE ：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>Invoke-Expression (&amp;starship init powershell)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录</span></span>
<span class="line"><span>Set-PSReadLineOption -Colors @{ InlinePrediction = &#39;#875f5f&#39;} # 增加预测内容在亚克力背景下的可读性</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Set-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全</span></span>
<span class="line"><span>Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 Intellisense</span></span>
<span class="line"><span>Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销</span></span>
<span class="line"><span>Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录</span></span>
<span class="line"><span>Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>根据我的习惯，我做了以下定制：</p><p>Tab映射为补全和菜单补全（只有一项时就直接补全） 上下箭头映射为历史记录搜索，没有输入则是默认行为 最重要的是，将预测文本来源为历史记录，提供了命令建议，这个键位是右箭头</p><p>检测是否有配置好文件</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">Test-path</span><span style="--shiki-light:#001080;--shiki-dark:#E06C75;"> $profile</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="安装字体" tabindex="-1">安装字体 <a class="header-anchor" href="#安装字体" aria-label="Permalink to &quot;安装字体&quot;">​</a></h2><p>在Nerd font网站下载字体文件压缩包。<a href="https://www.nerdfonts.com/" target="_blank" rel="noreferrer">https://www.nerdfonts.com/</a></p><p>解压字体到~/.fonts文件夹内。</p><p>运行fc-cache -fv添加字体。</p><p>为了显示效果完美呈现，可以在使用终端的系统中安装一个 Nerd Font 字体，用来显示一些图标字符。例如在 Windows 中可以执行：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">choco</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> firacodenf</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>并在 Windows Terminal 中启用该字体： <img src="`+d+'" alt=""></p><h2 id="starship-使用-rust-编写-对性能的影响很小" tabindex="-1">Starship 使用 Rust 编写，对性能的影响很小 <a class="header-anchor" href="#starship-使用-rust-编写-对性能的影响很小" aria-label="Permalink to &quot;Starship 使用 Rust 编写，对性能的影响很小&quot;">​</a></h2><p>Starship 的配置全部放在一个名为 starship.toml 的文件中</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://sspai.com/post/72888?utm_source=twitter&amp;utm_medium=social" target="_blank" rel="noreferrer">https://sspai.com/post/72888?utm_source=twitter&amp;utm_medium=social</a></p><p><a href="https://chlorinec.top/post/technology/shell-optimize/" target="_blank" rel="noreferrer">工欲善其事，必先利其器——打造自己趁手的终端体验</a></p><p><a href="https://www.jianshu.com/p/9988dad3c08d" target="_blank" rel="noreferrer">windows terminal加powershell7美化命令行操作</a></p><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;Contributors&quot;">​</a></h2>',43);function b(m,k,g,v,w,y){const a=i,e=p,n=t;return h(),r("div",null,[u,s(a,{readTime:"3",words:"875"}),s(e),s(n)])}const F=l(c,[["render",b]]);export{P as __pageData,F as default};
