import{_ as l,a as i,b as c}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.BCVHfIj7.js";import{_ as t,c as r,I as a,j as s,a as o,a7 as d,o as u}from"./chunks/framework.DGCt2JJv.js";import"./chunks/dayjs.min.DZyl58SH.js";const j=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"tools/Yalc本地调试组件库方案.md","filePath":"tools/Yalc本地调试组件库方案.md","lastUpdated":1711384503000}'),h={name:"tools/Yalc本地调试组件库方案.md"},b=s("h2",{id:"组件库本地调试自动化方案",tabindex:"-1"},[o("组件库本地调试自动化方案 "),s("a",{class:"header-anchor",href:"#组件库本地调试自动化方案","aria-label":'Permalink to "组件库本地调试自动化方案"'},"​")],-1),m=d(`<p><a href="https://www.jianshu.com/p/c079d34eb347" target="_blank" rel="noreferrer">https://www.jianshu.com/p/c079d34eb347</a></p><p>自动化流程 自动化流程通过使用nodemon监听文件修改后，自动执行组件库打包，再使用 yalc push 进行组件库发布，项目只要 yalc add [package] 后，后续就能直接热更新下预览变更了</p><h3 id="全局安装nodemon和yalc" tabindex="-1">全局安装nodemon和yalc： <a class="header-anchor" href="#全局安装nodemon和yalc" aria-label="Permalink to &quot;全局安装nodemon和yalc：&quot;">​</a></h3><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">npm</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;"> -g</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> yalc</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;">  //</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> 全局安装</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">npm</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;"> -D</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> nodemon</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> //</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> 组件库安装</span></span>
<span class="line"><span style="--shiki-light:#008000;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"># 或</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">yarn</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> global</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> add</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> yalc</span></span>
<span class="line"><span style="--shiki-light:#795E26;--shiki-dark:#61AFEF;">yarn</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> global</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> add</span><span style="--shiki-light:#A31515;--shiki-dark:#98C379;"> nodemon</span><span style="--shiki-light:#0000FF;--shiki-dark:#D19A66;"> -D</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="打包组件库" tabindex="-1">打包组件库 <a class="header-anchor" href="#打包组件库" aria-label="Permalink to &quot;打包组件库&quot;">​</a></h3><h3 id="本地发布组件库" tabindex="-1">本地发布组件库 <a class="header-anchor" href="#本地发布组件库" aria-label="Permalink to &quot;本地发布组件库&quot;">​</a></h3><p>组件库单独执行 yalc publish 时会把当前组件库下相关文件存储到本地共享的全局存储中，除了不会发布到真实远端仓库外，都和npm真实发包无异。 更好用的是 yalc publish --push 或者简称 yalc push ，它会将你的依赖发布到本地存储库（更新状态），并将所有更改传播到现有通过 yalc 安装的依赖中，下面会用到。 使用 yalc add xxx --link来添加</p><p>在组件库的 package.json 中添加 nodemon 脚本命令，这里可以新建一个 nodemon.json 的配置文件去配置详细的信息（具体配置可以去官网查看）。 nodemon 启动监听，当监听文件变化时自动 build 构建，并将库 yalc push 发布到缓存中。</p><p>如果当前构建后，package.json 中 private: true 时，直接 yalc push 会报错：Will not publish package with private: true use --private flag to force publishing. 需要使用 yalc push --private 强制发布。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>    &quot;scripts&quot;: {</span></span>
<span class="line"><span>        &quot;build&quot;: &quot;node scripts/dist.js&quot;,</span></span>
<span class="line"><span>        &quot;build:watch&quot;: &quot;nodemon --config &#39;nodemon.json&#39; -x &#39;npm run build &amp;&amp; cd dist &amp;&amp; yalc push --private&#39;&quot;</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>// nodemon.json</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  &quot;restartable&quot;: &quot;rs&quot;,</span></span>
<span class="line"><span>  &quot;ignore&quot;: [</span></span>
<span class="line"><span>    &quot;.git&quot;,</span></span>
<span class="line"><span>    &quot;node_modules/**/node_modules&quot;,</span></span>
<span class="line"><span>    &quot;package.json&quot;,</span></span>
<span class="line"><span>    &quot;nodemon.json&quot;,</span></span>
<span class="line"><span>    &quot;dist&quot;,</span></span>
<span class="line"><span>  ],</span></span>
<span class="line"><span>  &quot;verbose&quot;: true,</span></span>
<span class="line"><span>  &quot;execMap&quot;: {</span></span>
<span class="line"><span>    &quot;js&quot;: &quot;node --harmony&quot;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  &quot;events&quot;: {</span></span>
<span class="line"><span>    &quot;restart&quot;: &quot;osascript -e &#39;display notification \\&quot;App restarted due to:\\n&#39;$FILENAME&#39;\\&quot; with title \\&quot;nodemon\\&quot;&#39;&quot;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  &quot;watch&quot;: [&quot;src&quot;],</span></span>
<span class="line"><span>  &quot;env&quot;: {</span></span>
<span class="line"><span>    &quot;NODE_ENV&quot;: &quot;development&quot;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  &quot;ext&quot;: &quot;js,json,css,scss,vue&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="业务项目下只要执行-yalc-addxxx" tabindex="-1">业务项目下只要执行 yalc addxxx <a class="header-anchor" href="#业务项目下只要执行-yalc-addxxx" aria-label="Permalink to &quot;业务项目下只要执行 yalc addxxx&quot;">​</a></h3><p>在项目根目录下就会自动生成一个 yalc.lock 文件和 .yalc 目录，.yalc 目录类似 node_modules 那样，它存放着从存储库中拉取下来的依赖，yalc.lock 记录当前被替换的组件库版本信息，这些信息用来后面还原依赖包用。</p><h3 id="调试完毕-还原现场" tabindex="-1">调试完毕,还原现场 <a class="header-anchor" href="#调试完毕-还原现场" aria-label="Permalink to &quot;调试完毕,还原现场&quot;">​</a></h3><p>调试完毕后，要提交代码部署到公测环境时，执行 yalc remove --all（如果只引了一个依赖包也可直接 yalc remove [package]， yalc remove --all 会将当前所有从 yalc 存储中拉取的都还原），即可一键还原安装包现场， 上面说到的package.json会自动还原了依赖包版本、.yalc、yalc/lock都自动去掉了，还原了开发调试前的现场， 但是node_modules中的对应的组件库也去掉了，所以完成调试后本地只需要重新npm install安装正常版本即可后续开发。</p><h2 id="前端组件库本地开发调试的自动化流程实现" tabindex="-1">前端组件库本地开发调试的自动化流程实现 <a class="header-anchor" href="#前端组件库本地开发调试的自动化流程实现" aria-label="Permalink to &quot;前端组件库本地开发调试的自动化流程实现&quot;">​</a></h2><p><a href="https://blog.csdn.net/chenjixue/article/details/136141227" target="_blank" rel="noreferrer">https://blog.csdn.net/chenjixue/article/details/136141227</a></p><h2 id="项目中调试本地组件库的实践方案" tabindex="-1">项目中调试本地组件库的实践方案 <a class="header-anchor" href="#项目中调试本地组件库的实践方案" aria-label="Permalink to &quot;项目中调试本地组件库的实践方案&quot;">​</a></h2><p><a href="https://blog.csdn.net/weixin_43552879/article/details/127621284" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_43552879/article/details/127621284</a></p><p>使用yalc库 yalc是一个非常棒的工具，可以在本地开发和测试包/库，而不用发布到npm。</p><p>全局安装</p><p>npm install yalc –g</p><p>在组件库根目录下执行publish，发布组件库到本地仓库</p><p>yalc publish</p><p>在开发项目的根目录下执行add，安装该组件库</p><p>yalc add 组件库名</p><p>修改组件库代码后，推送更新</p><p>yalc push</p><p>本地调试完成后，在开发项目的根目录下执行remove</p><p>yalc remove –all</p><p>存在的问题： 修改组件库代码后，需要手动执行yalc push去更新开发项目的node_modules中组件库的代码，页面才会更新。 我们在开发组件库时一般都需要编译打包才能使用，所以在执行yalc push之前还要先执行npm run build进行打包，对于这一套操作yalc没有提供对应的自动化方案。</p><h3 id="安装yalc-watch2" tabindex="-1">安装yalc-watch2 <a class="header-anchor" href="#安装yalc-watch2" aria-label="Permalink to &quot;安装yalc-watch2&quot;">​</a></h3><p>npm i yalc-watch2 -D</p><p>在package.json文件中添加配置</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>    &quot;scripts&quot;: {</span></span>
<span class="line"><span>        &quot; yalc-watch2&quot;: &quot;yalc-watch2&quot;</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    . . .</span></span>
<span class="line"><span>    &quot;yalcWatch2&quot;: {</span></span>
<span class="line"><span>        &quot;watchFolder&quot;: &quot;src&quot;,</span></span>
<span class="line"><span>        &quot;buildWatchCommand&quot;: &quot;tsc --watch&quot;,</span></span>
<span class="line"><span>        &quot;extensions&quot;: &quot;js,jsx,ts,tsx,png,svg,gif,jpeg,css,less&quot;,</span></span>
<span class="line"><span>        &quot;prePushCommand&quot;: &quot;npm run build&quot;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>启动监听</p><p>npm run yalc-watch2</p><p>最终实现的效果就是，当我们修改并保存了组件库代码后，会执行npm run build进行组件库的编译打包，然后执行yalc push –changed，开发项目中依赖的组件库代码就会被更新，热更新检测到文件的修改后就会重新编译，然后更新页面，整个过程全部自动化完成，不需要人为操作。</p><p>如果我们修改了组件库代码，页面却一直不更新，可能是因为我们使用了webpack的缓存功能，在进行调试时可以先将webpack的缓存功能禁用掉，修改webpack.config.js配置：{ cache: false }。</p><h2 id="dev-torun-让组件库-yalc更丝滑简单" tabindex="-1">dev-torun:让组件库+yalc更丝滑简单 <a class="header-anchor" href="#dev-torun-让组件库-yalc更丝滑简单" aria-label="Permalink to &quot;dev-torun:让组件库+yalc更丝滑简单&quot;">​</a></h2><p>相信组件库开发+yalc本地发包已经成为基本操作了，但是一个新的组件开发过程中，会有无数次的修改调试优化，</p><p>要么一开始就是在项目里面写代码，但是后面可能迁移的时候就要多费时间 要么直接在组件库里面写，但是不可避免的需要多次构建 这个过程手动去搞的话会很蛋疼，于是就写了dev-torun这个工具来避免脱发，还能尽早下班</p><h4 id="配置说明" tabindex="-1">配置说明 <a class="header-anchor" href="#配置说明" aria-label="Permalink to &quot;配置说明&quot;">​</a></h4><p>config.listen_dir：监听目录变化 config.task_delay：延迟时间(秒)执行任务；终端输出倒计时 config.task_cmd：执行任务；当config.listen_dir修改保存后： 当前有任务在执行：等到执行成功后，再次倒计时后执行任务 当前没有任务执行：开始倒计时，然后执行任务 config.task_done：config.task_cmd执行成功的回调函数</p><h4 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><p>组件库自动构建build 成功回调后，使用 yalc publish，然后在task_done回调里面在对应项目路径(project_cwd)执行yalc update， 一般情况下项目会重新构建，第一次有问题的话，可能是因为项目启动缓存，可以重启对应项目试试</p><h4 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h4><p>npm i @zr-lib/dev-torun</p><h4 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h4><p>确保在项目下已经执行过 yalc link your-package</p><p>在组件库根目录新建 dev-torun.config.js</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>require(&#39;@zr-lib/dev-torun/jsTypes/config.types.js&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const npmCmd = process.platform === &#39;win32&#39; ? &#39;npm.cmd&#39; : &#39;npm&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/** @type {DevToRunConfig} */</span></span>
<span class="line"><span>module.exports = {</span></span>
<span class="line"><span>  listen_dir: &#39;./src/&#39;,</span></span>
<span class="line"><span>  task_delay: 5,</span></span>
<span class="line"><span>  task_cmd: npmCmd + &#39; run build &amp;&amp; yalc publish&#39;,</span></span>
<span class="line"><span>  task_done: () =&gt; {</span></span>
<span class="line"><span>    // console.log(\`\\n🚀 task_done. \${new Date().toLocaleString()}\\n\`);</span></span>
<span class="line"><span>    const path = require(&#39;path&#39;);</span></span>
<span class="line"><span>    const { execSync } = require(&#39;child_process&#39;);</span></span>
<span class="line"><span>    const project_cwd = path.resolve(__dirname, &#39;../your-project&#39;);</span></span>
<span class="line"><span>    // yalc update, (make sure has run &#39;yalc link your-package&#39;)</span></span>
<span class="line"><span>    const updateError = execSync(&#39;yalc update --replace&#39;, { stdio: &#39;inherit&#39;, cwd: project_cwd });</span></span>
<span class="line"><span>    if (updateError) throw updateError;</span></span>
<span class="line"><span>    else console.log(&#39;\\n&#39;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>添加 npm scripts</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;scripts&quot;: {</span></span>
<span class="line"><span>    &quot;dev-torun&quot;: &quot;dev-torun&quot;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果是全局安装的话，在终端进入组件库路径，直接执行dev-torun即可</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>npm run dev-torun</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="yalc使用文档" tabindex="-1">Yalc使用文档 <a class="header-anchor" href="#yalc使用文档" aria-label="Permalink to &quot;Yalc使用文档&quot;">​</a></h2><h3 id="使用场景-1" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景-1" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><p>1.在组件和插件依赖开发中，项目作为依赖库没办法单独直接运行，需要依赖进别的项目执行，这时候最常用的方式就是<code>npm link</code> 。但用<code>npm link</code>引入的依赖由于资源文件不在项目下，<code>webpack</code> 不会对其做预编译，导致实际构建或者运行时会报错，此时如果直接将文件复制进依赖目录则能正常运行，<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwclr%2Fyalc" title="https://github.com/wclr/yalc" target="_blank" rel="noreferrer">yalc</a> 能解决此类问题。</p><p>2.在一个项目中，我们会用 HRM 热更新来让我们修改的代码在浏览器中快速看到效果，快速验证我们的代码是否正确。</p><p>当项目开始变大，为了提效、跨项目复用，我们会不可避免的需要开始去拆分一些通用的 NPM 模块</p><h3 id="yalc工作流程图" tabindex="-1">yalc工作流程图 <a class="header-anchor" href="#yalc工作流程图" aria-label="Permalink to &quot;yalc工作流程图&quot;">​</a></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afecb4d875a643f8bc37263fec003822~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a6e73de5f4b4927afa3130b42867321~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><h3 id="yalc" tabindex="-1">Yalc <a class="header-anchor" href="#yalc" aria-label="Permalink to &quot;Yalc&quot;">​</a></h3><p><code>yalc</code>可以在本地将<code>npm包</code>模拟发布，将发布后的资源存放在一个全局存储中。然后可以通过<code>yalc</code>将包添加进需要引用的项目中。</p><p>这时候<code>package.json</code>的依赖表中会多出一个<code>file:.yalc/...</code>的依赖包，这就是<code>yalc</code> 创建的特殊引用。同时也会在项目根目录创建一个<code>yalc.lock</code>确保引用资源的一致性。因此，测试完项目还需要执行删除<code>yalc</code> 包的操作，才能正常使用。</p><p>整个过程相对于<code>npm link</code>会更加繁琐一些，要经过发包、添加依赖，结束后也需要做清除操作，但也正因此才避免了<code>npm link</code>的一些问题。</p><h3 id="安装-1" tabindex="-1">安装 <a class="header-anchor" href="#安装-1" aria-label="Permalink to &quot;安装&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>NPM:</span></span>
<span class="line"><span>npm i yalc -g</span></span>
<span class="line"><span>&lt;p&gt;Yarn:</span></span>
<span class="line"><span>yarn global add yalc</span></span>
<span class="line"><span>&lt;/p&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="发布依赖" tabindex="-1">发布依赖 <a class="header-anchor" href="#发布依赖" aria-label="Permalink to &quot;发布依赖&quot;">​</a></h3><p>在所开发的依赖项目下执行发布操作</p><p>此时如果存在<code>npm 生命周期</code>脚本：<code>prepublish</code>、<code>prepare</code>、<code>prepublishOnly</code>、<code>prepack</code>、<code>preyalcpublish</code> ，会按此顺序逐一执行。如果存在：<code>postyalcpublish</code>、<code>postpack</code>、<code>publish</code>、<code>postpublish</code>，也会按此顺序逐一执行。</p><p>想要完全禁用脚本执行需要使用</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>yalc publish --no-scripts</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>此时就已经将依赖发布到本地仓库了。</p><p>当有新修改的包需要发布时，使用推送命令可以快速的更新所有依赖</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>yalc publish --push</span></span>
<span class="line"><span>yalc push // 简写</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>参数:</p><ul><li><code>--changed</code>，快速检查文件是否被更改</li><li><code>--replace</code>，强制替换包</li></ul><h3 id="添加依赖" tabindex="-1">添加依赖 <a class="header-anchor" href="#添加依赖" aria-label="Permalink to &quot;添加依赖&quot;">​</a></h3><p>进入到项目执行</p><p>可以看到项目中添加了<code>yalc.lock</code>文件，<code>package.json</code>对应的包名会有个地址为<code>file:.yalc/</code>开头的项目。<br> 也可以使用</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>yalc add [my-package@version]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>将版本锁定，避免因为本地新包推送产生影响。</p><p>参数:</p><ul><li><code>--dev</code>，将依赖添加进<code>dependency</code>中</li><li><code>--pure</code>，不会影响<code>package.json</code>文件</li><li><code>--link</code>，使用<code>link</code>方式引用依赖包，<code>yalc add [my-package] --link</code></li><li><code>--workspace (or -W)</code>，添加依赖到workspace:协议中</li></ul><h3 id="更新依赖" tabindex="-1">更新依赖 <a class="header-anchor" href="#更新依赖" aria-label="Permalink to &quot;更新依赖&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>yalc update</span></span>
<span class="line"><span>yalc update [my-package]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>会根据<code>yalc.lock</code>查找更新所有依赖</p><h3 id="移除依赖" tabindex="-1">移除依赖 <a class="header-anchor" href="#移除依赖" aria-label="Permalink to &quot;移除依赖&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>yalc remove [my-package]</span></span>
<span class="line"><span>&lt;p&gt;yalc remove --all // 移除所有依赖并还原</span></span>
<span class="line"><span>&lt;/p&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="查看仓库信息" tabindex="-1">查看仓库信息 <a class="header-anchor" href="#查看仓库信息" aria-label="Permalink to &quot;查看仓库信息&quot;">​</a></h3><p>当我们要查看本地仓库里存在的包时</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>yalc installations show</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>要清理不需要的包时</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes light-plus one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>yalc installations clean [my-package]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;Contributors&quot;">​</a></h2>`,98);function k(y,g,v,q,x,f){const n=l,e=i,p=c;return u(),r("div",null,[b,a(n,{readTime:"9",words:"2.5k"}),m,a(e),a(p)])}const P=t(h,[["render",k]]);export{j as __pageData,P as default};
