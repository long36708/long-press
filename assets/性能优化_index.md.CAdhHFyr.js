import{_ as t,a as r,b as o}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.BCVHfIj7.js";import{_ as n,c as h,I as l,a7 as d,o as s}from"./chunks/framework.DGCt2JJv.js";import"./chunks/dayjs.min.DZyl58SH.js";const w=JSON.parse('{"title":"防抖和节流","description":"","frontmatter":{},"headers":[],"relativePath":"性能优化/index.md","filePath":"性能优化/index.md","lastUpdated":1719038302000}'),p={name:"性能优化/index.md"},c=d('<h1 id="防抖和节流" tabindex="-1">防抖和节流 <a class="header-anchor" href="#防抖和节流" aria-label="Permalink to &quot;防抖和节流&quot;">​</a></h1><table tabindex="0"><thead><tr><th>特性</th><th>防抖</th><th>节流</th></tr></thead><tbody><tr><td>原理</td><td>在事件触发后，等待一定的延迟时间。如果在此时间内再次触发了事件，则重新开始计时。</td><td>在一定时间间隔内只允许函数执行一次。</td></tr><tr><td>关注点</td><td>停止触发后的执行</td><td>在活动期间有规律的执行</td></tr><tr><td>使用场景</td><td>适用于连续事件只需在最后一次触发时响应的场景，如输入框自动完成。</td><td>适用于限制函数执行频率的场景，如滚动事件、窗口调整大小等。</td></tr><tr><td>效果</td><td>只有在事件停止触发后的一定时间内没有再次触发事件时，函数才会执行。</td><td>即使事件频繁触发，函数也只会按照设定的时间间隔执行。</td></tr></tbody></table><h1 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/556204/1662443400929-2bf40146-0753-4d6a-9422-8ce609c06025.png?x-oss-process=image%2Fresize%2Cw_1788%2Climit_0" alt=""></p><p>优秀的性能，给用户流畅的体验，降低用户的流失。本文介绍了提升前端性能的思路和方法。</p><h2 id="包含内容" tabindex="-1">包含内容 <a class="header-anchor" href="#包含内容" aria-label="Permalink to &quot;包含内容&quot;">​</a></h2><p>性能可分为 加载时性能 和 运行时性能。加载时性能指网页加载过程的性能。运行时性能指网页加载好后，用户在使用过程中的性能。</p><h2 id="整体步骤" tabindex="-1">整体步骤 <a class="header-anchor" href="#整体步骤" aria-label="Permalink to &quot;整体步骤&quot;">​</a></h2><p>提升性能包含三步:</p><ol><li>发现问题。</li><li>定位问题。</li><li>优化。</li></ol><h2 id="_1-发现问题" tabindex="-1">1 发现问题 <a class="header-anchor" href="#_1-发现问题" aria-label="Permalink to &quot;1 发现问题&quot;">​</a></h2><p>可以通过一些指标来发现性能问题。</p><h3 id="加载时性能" tabindex="-1">加载时性能 <a class="header-anchor" href="#加载时性能" aria-label="Permalink to &quot;加载时性能&quot;">​</a></h3><p>度量加载时性能的一个主流指标是： <a href="https://web.dev/i18n/zh/vitals/" target="_blank" rel="noreferrer">核心 Web 指标(Core Web Vitals)</a>。</p><blockquote><p>核心 Web 指标是适用于所有网页的 Web 指标子集，每位网站所有者都应该测量这些指标，并且这些指标还将显示在所有 Google 工具中。每项核心 Web 指标代表用户体验的一个不同方面，能够进行实际测量，并且反映出以用户为中心的关键结果的真实体验。</p></blockquote><p>指标包含三个方面：加载性能、交互性和视觉稳定性。具体如下：</p><ol><li>Largest Contentful Paint (LCP) ：最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的2.5 秒内发生。</li><li>First Input Delay (FID) ：首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为100 毫秒或更短。</li><li>Cumulative Layout Shift (CLS) ：累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1或更少。</li></ol><p>查看当前页面 <code>核心 Web 指标</code>。有多种方式:</p><ol><li>在 Chrome 的 Rendering Tab 中查看。</li><li>npm 包： <a href="https://www.npmjs.com/package/web-vitals" target="_blank" rel="noreferrer">web-vitals</a>。</li></ol><p>感兴趣也可以了解下 <a href="https://www.apdex.org/" target="_blank" rel="noreferrer">Apdex 应用性能指数</a>。</p><blockquote><p>Apdex (Application Performance Index) 应用性能指数, 也被称为 满意度。是由 Apdex 联盟开放的用于评估应用性能的工业标准。标准从用户的角度出发，将对应用响应时间的表现，转为用户对于应用性能的可量化为范围为 0 - 1 的满意度评价。</p></blockquote><h3 id="运行时性能" tabindex="-1">运行时性能 <a class="header-anchor" href="#运行时性能" aria-label="Permalink to &quot;运行时性能&quot;">​</a></h3><p>度量加载时性能的一个主流指标是：RAIL 模型。RAIL 由四个方面组成： Response，Animation，Idel，Load。具体如下：</p><ol><li>Response &lt; 100毫秒。</li><li>Anmiation: FPS 接近 60。</li><li>Idel：任务完成时间 &lt; 50毫秒。</li><li>Page Load: 重要内容的加载时间 &lt; 1秒。</li></ol><h2 id="_2-定位问题" tabindex="-1">2 定位问题 <a class="header-anchor" href="#_2-定位问题" aria-label="Permalink to &quot;2 定位问题&quot;">​</a></h2><h3 id="加载时性能-1" tabindex="-1">加载时性能 <a class="header-anchor" href="#加载时性能-1" aria-label="Permalink to &quot;加载时性能&quot;">​</a></h3><p>可以通过 <a href="https://www.webpagetest.org/" target="_blank" rel="noreferrer">WebpageTest</a> 和 Chrome Lighthouse 来知道整体的加载时性能情况和定位问题。</p><p>可以通过 Chrome Network 来知道网络资源加载情况。</p><p>如果用的 Webpack， 用 Webpack Analysis 找到一些大的 chunk。</p><h3 id="运行时性能-1" tabindex="-1">运行时性能 <a class="header-anchor" href="#运行时性能-1" aria-label="Permalink to &quot;运行时性能&quot;">​</a></h3><p>可以通过 Chrome 的 Performance Tab，实时 FPS 图，Memory Tab 来定位问题。</p><h2 id="_3-优化" tabindex="-1">3 优化 <a class="header-anchor" href="#_3-优化" aria-label="Permalink to &quot;3 优化&quot;">​</a></h2><h3 id="加载时性能-2" tabindex="-1">加载时性能 <a class="header-anchor" href="#加载时性能-2" aria-label="Permalink to &quot;加载时性能&quot;">​</a></h3><p>分析整个加载的链路。具体方法如下：</p><ol><li>减少请求次数。 <ol><li>缓存。</li><li>接口的缓存。</li><li>文件的离线缓存。</li><li>内联体积小(&lt;5KB)的图片。将图片转化成 Base64 字符串。</li><li>合并。 <ol><li>文件合并。</li><li>接口合并。 技术：GraphQL。BFF。</li></ol></li></ol></li><li>减少体积。 <ol><li>压缩。</li><li>传输时的压缩。GZip，Brotli，Zopfli 等压缩算法。其中 Brotli 的压缩率比 GZip 算法高。</li><li>文件内容的压缩。 比如，压缩 js 用 UglifyJS，压缩图片 等。</li><li>图片：选择合适的文件格式。图片： Webp，jpeg，png。</li><li>代码：去掉不必要的代码。</li><li>去掉没用的代码。工具：tree-shaking 等。</li><li>体积大的代码：拆分(code-splitting)。特别的框架和业务代码合在一起的，抽取出框架代码(webpack vendor)。</li><li>有些包，体积挺大，但在业务中只用了该包少量的功能，考虑去掉。</li></ol></li><li>提升传输速度。 <ol><li>使用 CDN。</li><li>加载的优先级。区别核心内容和增强体验的内容。</li><li>首屏。</li><li>核心功能。</li><li>按需加载。</li><li>并行数量的控制。</li><li>使用更高版本的 HTTP 协议。HTTP/2，HTTP/3。</li><li>提升服务器端的响应速度。</li></ol></li></ol><h3 id="运行时性能-2" tabindex="-1">运行时性能 <a class="header-anchor" href="#运行时性能-2" aria-label="Permalink to &quot;运行时性能&quot;">​</a></h3><ol><li>渲染优化。 <ol><li>减少回流和重绘 <ol><li>复杂的动画，用绝对定位来脱离文档流，来减少重绘。</li></ol></li><li>组件缓存。</li><li>减少更新 DOM 的数量。 Visual DOM。</li><li>减少 DOM 的数量。</li></ol></li><li>CSS 的优化。 <ol><li>选择器的优化。 <ol><li>右侧指定性强的。</li><li>减少层级。</li></ol></li></ol></li><li>计算优化 <ol><li>防止计算密集型的的内容卡UI。放在后台算(Service work) 或给服务器做。</li><li>节流和防抖。</li><li>内存泄漏。</li></ol></li></ol><p>针对框架的优化：</p><ul><li><a href="https://mp.weixin.qq.com/s/Sx9HiNgxOV6w0hNdLksonw" target="_blank" rel="noreferrer">React 运行时性能优化之减少渲染组件的次数</a></li><li><a href="https://mp.weixin.qq.com/s/nJljYPXnRSSrxOybDEkhbA" target="_blank" rel="noreferrer">Vue 运行时性能优化之减少渲染组件的次数</a></li></ul><p>其他：</p><ul><li><a href="https://mp.weixin.qq.com/s/fwgFPvbgF6sFB97qRitHlQ" target="_blank" rel="noreferrer">提高页面渲染速度的 3 个 CSS 技巧</a></li></ul><h2 id="contributors" tabindex="-1">Contributors <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;Contributors&quot;">​</a></h2>',42);function b(u,m,_,f,q,k){const e=t,a=r,i=o;return s(),h("div",null,[c,l(e,{readTime:"4",words:"1.5k"}),l(a),l(i)])}const C=n(p,[["render",b]]);export{w as __pageData,C as default};
